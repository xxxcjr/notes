" Last Modified: 2011-11-05 星期六 16:11:56 [Athena]
" 本文绝大部分来自台湾李正果先生写的《大家来学Vim》，小部分来自网络上的其它文章，极少部分来自我的画蛇添足。


大家来学 Vim

一个历久弥新的编辑器
        李果正 EdwardG.J. Lee 
        Email: edt1023@info.sayya.org 



1 进来先看看

鉴於仍有许多人还没找到顺手的编辑器，而许多想学 vi的人又觉得无从下手，因此在此提出一些个人的心得，希望能对这些朋友有点帮助。或许也减少一点 FAQ吧！
真要深入的话，大多数的前辈都认为 vi比 emacs/xemcas还难学。但谁又真的需要熟悉编辑器的所有功能呢？你大可以边用边学啊！需要用到的先学，其它的就放一边，只要能善用一些常用到的功能，又何必要那么深入呢？而且您在使用当中经常会发现一些新功能，这又会马上让您给赚到了。 

1.1 为什么选Vim
最最重要的原因是可以正确处理中文！其它如 elvis, vile, nvi在中文方面都会有问题 (nvi-m17n的版本已可以正确处理 Big5中文，但功能仍不及 Vim1完整 )。另外就是许多作业系统都有 Vim可用。当然如果您不需要中文支援的话，也建议使用 elvis。vile则有 emacs的味道，而 nvi大概是最忠於原味的了！至於原始 vi的书已有中文翻译（ O’Reilly），各位到大一点的书局翻翻就有了。所以选定 Vim做对象，兼述及 elvis，至少她不「排斥」中文。另一个原因， Vim不仅是自由软体（ Free Software4），也是慈善软体（ CharityWare5），如有赞助或评比得奖（几乎是年年最佳编辑器奖 :），所得皆救助乌干达 AIDS孤儿。您要使用当然是免费，您要捐款赞助当然是不勉强啦！但如果有评比有奖金可拿的， 

您去投她一票就是功德无量了。另外，如果想网路购书，可以透过 ICCF的网页 http://iccf-holland.org/click.html来订购，这样 Amazon会付一些赞助金给 ICCF，完全不会多花您一毛钱。另外 Vim的正则表达式 (regular express)颇完整，您也可借这个机会学 regexp，因为您在 sed, awk, perl, less, grep. . .中也是要用到，早点习惯 regexp，您生活在 Linux(Un*x)的世界会更美好。学了 regexp您会有点看不起 Windows系统中的找寻工具的。由於是慈善软体，广结善缘，因此连中文繁体都支援，不简单。但也因此最近的版本有点肥，但又不会太肥 (比 xemacs好多了啦！ )。这么可爱的软体，能不用她吗？ 

1.2 何处抓 Vim(elvis)？ 
 http://www.vim.org/ 
 http://vim.sf.net/download.php 
 ftp://ftp.vim.org/pub/vim/

找个自己中意的 mirro站抓。或许也顺便抓 Win32的可执行档回来在 windows系统中使用。别忘了 runtime档也要抓，否则会无法找到需要的档案来执行。 
        http://elvis.the-little-red-haired-girl.org/
也可试试 elvis（当然也是自由软体）。 
            ftp://ftp.cs.berkeley.edu/ucb/4bsd/ 
            ftp://ftp.foretune.co.jp/pub/tools/nvi-m17n/ 

nvi-m17n也可以一试，目前已可以支援中文。
            目前最新的版本， Vim是 6.1，elvis是 2.2h-beta，nvi是 1.79。当然，本文的重点是放在 Vim。 

1.3 编译安装
只讲重点，避免罗嗦！ 

1.3.1 Vim 
1.configure时加上： 
--enable-multibyte 
--enable-xim 
--enable-fontset 
--enable-gui=gtk 
--enable-perlinterp需嵌入 perl的话 
--enable-pythoninterp需嵌入 python的话 
GUI可有好几种选择，但建议使用 gtk+，比较稳定。 


2.~/.vimrc加入： 
set enc=big5 
set guifontset=英文字型，中文字型
设了 guifontset就不能设 guifont否则会优先使用 
guifont，这样就找不到中文字型了！ console下或 xterm
下的话，就看您用什么字型就显示什么字型，和 guifontset无关。

英文字型要用固定字，我个人的实际设定例子 (1024x768)： 
set guifontset=-b&h-*-medium-r-normal-*-*-120-*-*-m-*-*-*, 
\-arphic-*mingti2l*-medium-r-normal-*-*-190-*-*-c-*-big5-0 

Windows中文版无需设 guifontset，只要设 guifont即可。而且他
的设定档是 \Program Files\Vim\_vimrc。例如： 

set guifont=Andale_Mono:H11:W6
或 
set guifont=细明体 :H11:W6

对於 UTF-8编码的文件，可能需要指定「细明体」才能正确显示中文。 

3.locale要设成 zh_TW.Big5，意思就是您的系统的 i18n 支援要完整，我个人的设定如下： 

unset LC_ALL 
export LC_CTYPE=zh_TW.Big5 

1.3.2 elvis 
elvis没什么好说的， GUI版本要靠靠 XA+CV来显示及输入中文，因为他还不支援 i18n/XIM。但在 console/rxvt下则可以显示、输入中文。至於其他外观调整，就请 man elvis。 

1.3.3 nvi-m17n 
nvi是在 *BSD系统的标准配备， m17n(multilingualization,取前 m及后 n及其中的 17个英文字母，合成 m17n)则是日本朋友修改的版本，目前也可以用於中文，如果您系统上也有 nvi-m17n的话，可以设定 /.nexrc如下： 
set noskipdisplay 
set displayencoding=big5 
set inputencoding=big5 
set fileencoding=big5 
set autodetect=tw 

1.4 勤前教育 
Vim的基本模式（ basic mode）可有六种： 

1.4.1 常态模式（ Normal mode） 
您一进入vim就是处於这常态模式，只能下按键指令，不能输入编辑文字。这些指令可能是游标移动的指令，也可能是编辑指令或寻找替换指令。 

1.4.2 插入模式（ Insert mode）
按 i就会进入插入模式，此时才可以键入文字，写您的文章，按 Esc又会回到正常模式。此时在状态列会有 -INSERT -字样。 

1.4.3 命令列模式（ Cmdline mode or Command-line mode）
按冒号： (别忘了 Shift键)就会进入命令列模式，左下角会有一个冒号：出现可下 ex6指令。也是按 Esc回命令列模式。反正正常状态都是处於常态模式，这样才不会把您辛苦打字的文章给随便搞乱掉。搜寻时的 /及 ?按键也是属於命令列模式。 6vi, ex, sed都是衍化自 ed。ed是一个很古老的行编辑器，就好像 DOS下的 edline一样。当然 DOS下的 edline也是学 ed而来的，但功能可就不能同日而语了！有兴趣可 man ed学看看，有些时候会只有 ed可以用（当机救助的时候）。 ex的操作和 ed，除了多了个冒号外，几乎是一样的。 

1.4.4 反白模式（ Visual mode）
这就是把需要处理的文字反白起来，等待处理的模式，底部状态最会有 -VISUAL -或 -VISUAL LINE -或 -VISUAL BLOCK -字样。详细会在第 7章，页 26，做介绍。 

1.4.5 选择模式（ Select mode）
和反白模式的异同待了解。 

1.4.6 Ex模式（ Ex mode）
这和命令列模式是一样的，但下了命令后不会返回，会留在行编辑器 ex的状态，有一个冒号在那儿，等待输入命令。由 gQ按键可以进入 Ex模式，输入 visual可以返回正常模式。
    其它还有五种的额外模式（ additional mode）！这里不准备说明，会在第 3.1节，页 10做介绍。反正，使用 Vim的无上心法就是，有问题先考虑按 Esc键回到常态模式再说。 

1.5 基本教练： step by step 

1.5.1 由命令列来开档 
vim test.txt或 gvim test,txt，如果您的系统 vi是 vim的连结档话，就可以直接用 vi test.txt。以下就直接用 vim代表 vi，gvim，elvis，因操作是一样的有不同的地方会加注说明。 

1.5.2 先进入 
vim后再开档进入 vim后，使用冒号命令 :e test.txt，就可以编辑 test.txt这个档。第 1.5.1小节及第 1.5.2小节这两个开档法，如果test.txt不存在的话，就会开一个以test.txt为名的新档案。如果是 gvim，可由 icon(gtk版本才有 )或功能表来叫出 .le browser来选看看您要编辑哪一个档，但如果您是初学的话不建议您这么做， vi就是以按键快速闻名，这是她的优点，您还是学起来吧，不然没有 GUI的时候会很不习惯的。 

1.5.3 编写文件
进入 vim后，按 i进入插入模式，就可以编写您的文件了。在 vim游标的移动可以由方向键来移动。 Backspace键可消去前一个字元，中文的话是一个中文字。 Del键可删除游标所在处的字元（中文字）。
原始 vi是不能在插入模式随意移动游标的，得进入正常模式才能移动，因此就常常要按 Esc来变换模式。 vim及 elvis都打破了这个规矩。 

1.5.4 存档、离开
如果您写好您的文件，就可以按 Esc回到正常模式，然后 :w就会存档（注意，是冒号命令），但还不会离开 vim，要离开可按 :q，就可以了！也可以合起来用， :wq，就样就会存档后离开。怎么样，也不会很难吧！只不过操作方式和别的编辑器不一样罢了，这样岂不是很有个性。 :-) 尽量记住按键的意义，才不必死背，如 e是 edit(编辑 )，w是 write(写入 )，q是 quit(停止、离开)。

这里要提醒大家一下，许多 distributions中会编译一个小型的 vim，启动会比较快一点，但缺乏许多本文要用到的功能，因此，建议您使用 vim/gvim，而暂时避免使用 vi，或者就把 vi直接连结到正常的 vim上去。 Slackware Linux的话，他的 vi是连结到 elvis的，也请使用 vim/gvim为指令，或改变 vi的连结。而 *BSD系统，使用的很可能就是 nvi，这些请使用时注意一下，以免和文中内容所述不符。如果不确定自己是使用哪一种版本的 vi，可以进入 vi后按冒号 :后再输入 ver，然后按 Enter，就会得知是哪一种版本的 vi，如果是 vim的话，还会显示前有 +/–号的各功能，有 +号的，表示有编译进去， –号的表示没有这项功能。

好了，这是就编辑的整个过程。下回开始是详述各部份的功能，把 Vim解剖开来讲，您可以马上现学现卖。由於 vi/vim的操作方式很有个性，因此，用了一次就会记住有这么一个功能，想忘也忘不了，但有时按键难免会忘记，有这么一种功能大概是忘不了的，查了几次指令就可以记得住了。 

-----------------------------第1章结束-------------------------------

2 游标的移动

本节所述皆是在 common-mode(c-mode，在 Vim又名 normal-mode，就是刚进入 vim，不能输入文字的状态 )下的移动，原始的 vi只能在 c-mode移动游标，在 insert-mode只做文字的输入，而不做游标的移动。当然 Vim及 elvis的方向键是不论在那一种 mode皆可移动自如。 

2.1 基本的游标移动 
h 左，或 Backspace或方向键。  
j 下，或 Enter或 +（要 Shift键），或方向键。  
k 上，或方向键或 –（不必 Shift键）。  
l 右，或 Space或方向键。  

H 光标移动到当前窗口的顶部，4H表示把光标移动到距离窗口顶部4行的位置
M 光标移动到当前窗口的中间
L 光标移动到当前窗口的底部

Ctrl+f 即 PageDown翻页（ Forward，向前、下翻页）。  
Crtl+b即 PageUp翻页（ Backward，向后、上翻页 )。

Vim还可移动光标所在行相对于屏幕的位置。

zt 将当前行置于屏幕顶端
zz 将当前行置于屏幕中间
zb 将当前行置于屏幕底端
ctrl-e 所在行向上移
ctrl-y 所在行向下移
    使用hjkl键的移动是为了使手不必离开打字区（键盘中央的部位），以加快打字的速度，如果各位不习惯，那就使用方向键吧！其实，一旦习惯了以后，对於编辑工作的效率会有很大的帮助，而且有许多工作站的 vi只能使用 hjkl的移动方式，因此可能的话，尽量熟悉 hjkl的游标移动。 Backspace及 Space的移动方式是到了行首或行尾时会折行，但方向键或 hl键的移动则在行首或行尾时您继续按也不会折行。转折换行的功能是 Vim的扩充功能， elvis无此功能。 

jk及使用方向键的上下移动游标会尽量保持在同一栏位。使用 Enter，+，–的上下移动，游标会移至上（下）一行的第一个非空白字元处。
好像有点复杂，各位就暂时使用方向键来移动就简单明白了！等您爱上了 Vim后再来讲究吧。 

2.2 进阶的游标移动 

0是数目字0而不是英文字母o。或是 Hmoe键，移至行首，（含空白字元）。  
. 移至行首第一个非空白字元，注意，要 Shift键。  
$ 移至行尾，或 End键。要 Shift键。  
G 移至档尾（全文最后一行的第一个非空白字元处）  
gg 移至档首（全文第一行之第一个非空白字元处）。 

't 跳转到标记t所在的行
`t 跳转到标记t所在的行并精确到列 

在正则表达式（ regular expression）中， .是匹配行首， $是匹配行尾。 
gg是 Vim的扩充功能，在 elvis或原始 vi中可用 1G来移至档首（是数字 1不是英文字 l）。 G之原意是 goto，指移至指定数目行之行首，如不指定数目，则预设是最后一行。 

w移至次一个字（ word）字首。当然是指英文单字。 W同上，但会忽略一些标点符号。 e移至后一个字字尾。 E同上，但会忽略一些标点符号。 b移至前一个字字首。 B同上，但会忽略一些标点符号。 H移至萤幕顶第一个非空白字元。 M移至萤幕中间第一个非空白字元。 L移至萤幕底第一个非空白字元。这和 PageDown，PageUp不一样，内文内容并未动，只是游标在动而已。 n|移至第 n个字元 (栏)处。注意，要用 Shift键。 n是从头起算的。 :n移至第 n行行首。或 nG。 

2.3 特殊的移动 

    )移至下一个句子（ sentence）首。 (移至上一个句子（ sentence）首。 sentence（句子）是以 .!?为区格。 }移至下一个段落（ paragraph）首。 {移至上一个段落（ paragraph）首。 paragraph（段落）是以空白行为区格。 

%这是匹配 {}，[]，()用的，例如游标在 {上只要按 %，就会跑到相匹配的 }上。 

另还有一些 Vim的特殊按键，但这得留待最后再来说明，否则各位恐怕会头昏眼花了。 

-----------------------------第2章结束-------------------------------

3 基本编辑指令

这个单元就开始进入主题了。下编辑指令都是在常态模式，就是您一进入 Vim时的模式，只能下指令，不能键入文字。如果印象模糊，请瞄一下第一个单元的内容。这个单元说的是基本的编辑指令，有些比较特殊的编辑指令，因为太有个性了，所以会独立成一个单元来说明。 

3.1 五种额外模式（ additional mode）

    这里要对基本模式（请参考第 1.4节，页 4）外的五种额外模式做介绍，以下的章节会有机会碰上。为什么会有这么多模式？这样岂不是很易就搞混？其实一般编辑不必太在意一些模式，您只要在各种模式下亲自去操作几次就会知道这些模式的作用，不必特意去记忆他，这些模式和基本模式都有连带关系的。 

3.1.1 操作等待模式（ operator-pending mode） 
这其实和一般的常态模式一样，只不过是指在常态模式下了某些编辑指令，等待其他动作的状态。 

3.1.2 取代模式（ replace mode）

3.1.3 插入常态模式（ insert normal mode）
这是一个很特殊的模式，在插入模式时，进入输入状态，但按 Ctrl+O就会进入插入常态模式，和常态模式一样，只不过执行完所下的指令后又会马上返回原来的插入模式继续输入文字。状态列会有 -(insert) -字样，是小写有小号的。 

3.1.4 插入反白模式（ insert visual mode）

这和插入常态模式一样，只不过在按 Ctrl+O后所执行的是反白的 Ctrl+V或 V或 v而进入反白模式，等反白模式结束又会返回原来的插入模式。状态列会有 -(insert) VISUAL -字样。 

3.1.5 插入选择模式（ insert select mode）
这和插入反白模式一样，只不过进入的是选择模式，而非反白模式。状态列会有 -(insert) SELECT -字样。 

3.2 进入插入模式的指令 

    指下 R指令时所处的状态。请参考第 3.4节，页 12。在状态列会有 -REPLACE -字样。 
i在游标所在字元前开始输入文字 (insert)。 
a在游标所在字元后开始输入文字 (append)。 
o在游标所在行下开一新行来输入文字 (open)。 
I在行首开始输入文字。此之行首指第一个非空白字元处，要从真正的第一个字元处
开始输人文字，可使用 0i或 gI(Vim才有 )。 
A在行尾开始输入文字。这个好用，您不必管游标在此行的什么地方，只要按 A就会
在行尾等著您输入文字。 
O在游标所在行上开一新行来输入文字。 
J将下一行整行接至本行 (Joint)。 并无相对的 split功能，可在插入模式下按 Enter来达成，当然如果您熟 macro的话，可自行定义。使用 J时，预设会消去本行的 EOL(End Of Line)字元，且上下行接缝间会留下一个空白字元，这符合英文习惯，却对中文会造成困扰，欲不留空白字元，可使用 gJ（大写 J）指令，但这是 Vim的扩充功能， elvis不适用。要和中文相容，可参考底下会说明的重排功能的 Vim script。请您随便找一个档案来试看看，光看文字说明太抽象了。 

3.3 删除指令 

x删除游标所在处之字元，在中文指一个中文字。在 Vim及 elvis亦可用 Del键。 
X删除游标前之字元。不可使用 Backspace键，除非是在插入模式。 Vim可以正确使用以上两个指令於中文，会删去一个中文字。 elvis则不行，一个中文字要删两次，即使用 xx。 
        dd删除一整行 (delete line)。 dw删除一个字 (delete word)。不能适用於中文。 dG删至档尾。 d1G删至档首。或 dgg(只能用於 Vim)。 D删至行尾，或 d$（含游标所在处字元）。 d0删至行首，或 d.（不含游标所在处字元）。请回忆一下 $及 .所代表的意义，您就
    可以理解 d$及 d.的动作，这就是 vi(m)可爱之处。 

3.4 取代及还原

r取代游标所在处之字元。 R进入取代模式（ replace mode），取代字元至按 Esc为止。 cc取代整行内容。或大写 S亦可。 cw替换一个英文字 (word)，中文不适用。 (change) .游标所在处字元之大小写互换。当然不能用於中文。别忘了 Shift！ C取代至行尾，即游标所在处以后的字都会被替换。或 c$。 c0取代至行首，或 c.。 s替换一个字元为您所输入的字串。和 R不同， R是覆盖式的取代， s则是插入式的取代，您可亲自实验看看。ㄟ！是小写的 s。 

Vim很有个性的，您在常态模式按了 r她就会停在那里等主人键入所要替代的字元，希望您这个当主人的，不要傻呼呼的也楞在那里，赶快键入您的新字元吧！ :-)Vim中可用於中文字，也就是可以替换一个中文字， elvis则不行。当然您的 Vim是要设在 big5/cp950的才行。怎么样！有没有看过如此有个性的取代方式？ㄚ！ r就是 replace啦！ 

3.5 撤销/恢复Undo/Redo

u这个太重要了，就是 undo，传统的 vi仅支援一次 undo，Vim及 elvis就不只了， Vim几乎是没有限制的。 
U在游标没离开本行之前，回复所有编辑动作。 
Crtl+r这个也是很重要，就是 redo键。 

VIM 提供了强大的Undo、Redo功能，这里要强调一下所谓的“强大”，因为一般的编辑工具支持的Undo、Redo都只是双向的，也就是说你可以重复 Undo到某点，再重复Redo，但是一旦你在某点做了一个新的动作，那么那些Redo动作就没了；但是VIM不是这样，它把动作序列以分支结构来记录。 也就是说，当你回退到某点，并开始做一个新的动作时，VIM把这个新的动作开始的动作序列作为一个新的分支，而那些在双向结构里失效的Redo动作序列则 保存在另一个分支上。

所以，不管你究竟做了什么，Undo了几步后又产生了什么新的动作，其实VIM都记录了下来。你要做的只是跨分支的切换。

介绍完了VIM特有的分支型Undo/Redo的概念，咱们再看一下具体的命令和操作：
:undolist                列出Undo操作列表
:undo <操作编号>          回退到某点（同时会选中所在的分支）
[次数]u                  执行指定次数的undo操作（次数默认是1）
g(-|+)                   在undo序列里前后移动
:earliar [数目](s|m|h)   退回到指定时间之前的样子（s－秒，m－分钟，h－小时）
:later [数目](s|m|h)     向前到指定时间的样子（s－秒，m－分钟，h－小时）


3.5 加上数目字

喔！骚到 Vim的痒处了，这是 Vim一个非常骚包的功能，只此一家别无分号（当然同源的 ed，sed等不在此限）。就是您可以在大部份的指令前加上数目字，代表要处理几次的意思。以下用实例来说明比较清楚。 
5dd 删除游标所在处（含）起算以下五行内容。妙吧！  
3r 按了 3r后，您键入一个英文字，则三个字元皆会被您所键入的英文取代。只要  
locale设定正确，中文也通喔！  
5J 将五行合并成一行。  
3x 删除三个字元。中文也通。  
5i A 然后按 Esc，插入五个 A。中文也可以！  
2i sys Esc 插入 syssys。中文也可以！  
5G 游标移至第五行，是从档首开始起算。和 :5作用相同。  
5l 移至右第五个字元处，当然 j是可以用方向键取代的。 

所有移动指令（参考第 2章，页 7）都可以加上数目字来控制，中文也通喔！其它的指令和数目字结合，就留待各位去发掘吧！最重要的是请您亲自操作看看，使用 Vim常常要动动脑筋，会有更妙的操作方式，想一次可以用很久喔！有人说，学电脑的人，动脑筋就是为了偷懒。 :-) 

3.6 简单重排功能 

.整行向右移一个 shiftwidth（预设是 8个字元，可重设）。 
.整行向左移一个 shiftwidth（预设是 8个字元，可重设）。 :set 
shiftwidth?可得知目前的设定值。 :set shiftwidth=4可马上重设
为 4个字元。 shiftwidth可简写成 sw。ㄟ，别忘了 Shift键！ 

:ce(nter)本行文字置中。注意是冒号命令！ 
:ri(ght)本行文字靠右。 
:le(ft)本行文字靠左。所谓置中、靠左右，是参考 textwidth(tw)的设定。如果 tw

没有设定，预设是 80，就是以 80个字元为总宽度为标准来置放。当然您也可
以如 sw一样马上重设。 
gqap整段重排，或 gqip，在段落中位何地方都可以使用。和中文的配合见下述。 
gqq本行重排。 
gqQ全文重排，是以游标所在处的段落开始重排至档尾。以空白行为段落的间 隔。重排的依据也是 textwidth。这里的重排是指您键入文字时没有按 Enter键，就一直在 keyin，这样会形成一个很长的一行（虽然萤幕上会替您做假性折行），重排后，则会在每一行最后加入 EOL。gq重排功能是 Vim才有的功能。 如果是利用 visual mode所标记起来的部份，只要按 gq就会只重排被标记的部份。请参考第七章的标示指令一节。
基本上 gq就是一个独立的重排指令，就像 d或 y是独立的删除、复制的指令一样，所以，当然是可以加上数目字加以控制，或和其他指一起用的，例如： 
    gq3q .重排三行 
    gq2ap .重排两个段落 
    gq5j .重排游标以下五行 (别忘了 j是向下移动， 5j就是向下移动五行，包括游

标所在处就是六行 ) 
    gq} . well，这是什么哇？ 
        gq) .这又是啥么哇？请复习一下第 2章的第 2.3特殊移动一节。并亲自做一

下实验看看。在中文文稿，通常就是一个段落。重排的功能本不是编辑器的主要功能，而是文书排版软体的工作，但简单的重排也是很方便，对 
於中文而言，处理上得多花些工夫，对於希望有中文重排功能的朋友，可下载 Vim script来使用： 
            http://info.sayya.org/~edt1023/vim/format.vim
            这是修改自日本朋友的贡献。把他置於 $VIMRUNTIME/plugin目录下，重新开启 vim就会生效，对於 J及 gqap都会考虑中文的细节。当然， Vim只是个文字编辑器，如果要做进一步的排版，需要由 o.ce类的文书处理软体，或更进一步的专业 TEX/LATEX/texinfo/tro./gro.排版软体来处理。 

------------------------------第3章结束------------------------------

4 复制（ yank） 

yank是什么意思？有疑问的请查一下字典吧！就好像是中医治疗中的「拔罐」的意思啦（是不是叫「拔罐」？知道的朋友指正一下吧）！反正在 Vim中，她就是复制 copy的意思。这在 Vim的思考逻辑里，就是「拔」 yank起来，「放」 put上去。其实复制的指令就是 y一个而已，为什么要独立成一个单元来说明呢？因为 Vim复制、贴上的功能实在太独特了，再配合第三单元介绍的数目字，及 Vim内部的缓冲区（寄存器）来使用的话，您会发现，原来 Vim肚子里还暗藏著秘密武器。 

4.1 指令说明 

yy 复制游标所在行整行。或大写一个 Y。  
2yy 复制两行， y2y也可以。ㄟ，请举一反三好不好！ :-)  
    y. 复制至行首，或 y0。不含游标所在处字元。  
y$ 复制至行尾。含游标所在处字元。  
yw 复制一个 word。  
y2w 复制两个字。  
yG 复制至档尾。  
y1G 复制至档首。  
p 小写 p代表贴至游标后（下）。  
P 大写 P代表贴至游标前（上）。整行的复制，按 p或 P时是插入式的贴在下（上） 
一行。非整行的复制则是贴在游标所在处之后（前）。  
"ayy 将本行文字复制到 a缓冲区。  a可为 26个英文字母中的一个，如果是小写的话，原先的内容会被清掉，如果是大写的话是 append的作用，会把内容附加到原先内容之后。 
"是 Enter键隔壁的那一个同上符号（ ditto marks），当然是要和 shift键同时按的。 
"ap将 a缓冲区的内容贴上。
这个缓冲区的术语在 Vim称为 registers，Vim扩充了相当多的功能。您用 d、c、s、x、y等指令改变或删除的内容都是放在 registers中的。例如：您用 dd删除的一行，也是可以使用 p来贴上的。只要是在缓冲区的内容都可以使用 p来贴上，不是一定要 y起来的内容才能用 p。因此您认为 p是 paste也可以，认为是 put可能较正确。 
5"ayy 复制五行内容至 a缓冲区。 
5"Ayy 再复制五行附在 a内容之后，现在 a中有十行内容了！ㄟ！不要我一直用 a您就认为只有 a可以用喔。 26个英文字母都可以的，交叉运用下，您会发觉 Vim肚量不小。

问题来了！忘记谁是谁的时候怎么办？ :reg（冒号命令）就会列出所有 registers的代号及内容。您现在就试著按看看。咦！怎么还有数目字、特殊符号的缓冲区，原来您刚刚删除（复制）的内容就预设放在 "这个缓冲区，然后依序是 0,1,2,. . .9。也就是说您按 p不加什么的话，是取出 "缓冲区的内容。

%指的是目前编辑的档案。 

#指的是前一次编辑的档案。还有其它的呀！这会在下一节做介绍。 

Tab补全的功能， elvis也有，但叫出 registers列表的命令则没有，您得自行记忆在您的脑袋瓜子里。而且 elvis的补全能力并没 Vim强。 

4.2 Register缓冲区

            在Vim里头，有许多不同种类的缓冲区，例如：置放一整个档案的 bu.ers缓冲区（请参考第 6.2节，页 22）；档案内容操作，如删除、 yank、置换，给 Put要用的 registers缓冲区；另外还有给书签要用的 marks缓冲区（请参考第 5.4节，页 20）。虽然这些内容不一定是放在 RAM记忆体内，有的是置於硬碟档案上，需要时才从档案存取，但这里通通把他当做是缓冲区，以方便理解。 

4.2.1 register的种类 

VIM里面的寄存器可以用来保存拷贝的文本、记录的宏、设置的书签等等，一般的编辑器都只有一个剪切板（MS Office加入了多个剪切板），而VIM和Emacs编辑器中的多寄存器可以实现多个剪切板的功能。VIM中有九类寄存器:

无名寄存器	"	最近一次删除/修改/替换操作的文本都会放入这个寄存器
10个数字寄存器	0-9	拷贝或者删除的文本存入这些寄存器，这些寄存器是循环使用
的，在每次存入内容到寄存器1时，原有的内容会依次存入到
后一个寄存器中。
小删除寄存器	-	删除内容少于一行时放入这个寄存器
26个命名寄存器	a-zA-Z  大小写无关。这些寄存器可以在拷贝或者删除等操作中指定使用。
    四个只读寄存器  :.%#	特殊用途。
表达式寄存器	=	特殊用途。
选择和拖放寄存器 *+~	用于与系统剪切板交互，以及接收拖放操作的内容。
黑洞寄存器	_	放到这里面的内容都被丢弃，这样可以删除或拷贝时不影响其它寄存器。
最后一次搜索模式寄存器 /	保存最后一次搜索的正则表达式。

使用:reg命令可以看到所有寄存器中的内容，使用"+y或者"*y可以将visual mode下选择
的内容拷贝到系统剪切板，使用"+p或者"*p可以将剪切板中的内容粘贴到VIM中，如果打开了
mswin特性的话则在insert mode下使用Ctrl-x，Ctrl-v，Ctrl-c了。

4.3 天大的指令 

.这是什么？ㄚ，是英文句点啦！没错，就是英文句点。什么意思？重复前次的编辑动作。这个指令太高明了，只要是编辑动作（移动游标不算，冒号命令也不算）都可以按英文句点来重复，要重复几次都可以。

    例如：您按了 yy，然后按 p就会复制、贴上一整行，如果要重复这个动作的话，就可以按 .，也可以把游标移到其它地方后再按。其它 dd，dw，r，cw等编辑指令都可以这样来重复。如果您要重复做某些编辑动作时，千万千万一定要想到有这么一个英文句点重复指令。ㄚ，拜托啦！您一定要常用这个指令。 

4.4 疑难杂症 

4.4.1 那mouse中键的剪贴功能还有吗？
当然还有，不管在 console或 Xterminal中都照用不误。当然在 windows下的话就不能用了，可以用 Shift+Insert来代替。 Ctrl+v在 Vim中另有作用，在 windows下就不必去麻烦它了。 

4.4.2 软体间互相 copy时,常常都搞得天下大乱耶！
要设成 :set paste。这是 Vim的扩充功能， elvis没有。那在 elvis怎么办？只好 :set noai1了。在 GUI的版本应不会有这种情形。

朋友！您睡著了吗？不要被吓到了，您只要开个档案，亲自操作一下就能心领神会。那用 mouse不是更方便吗？不见得， yyp来复制贴上一整行比较快，还是用 mouse来拉比较快？您可以试看看。 
1set的功能先不必去理它，会在第九章专门讨论。 

-----------------------------第4章结束-------------------------------

5 搜寻、替换

搜寻、替换的功能几乎是每个编辑器必备的功能，那在 Vim中有没有特殊的地方呢？当然有，您忘了， Vim是个性十足的编辑器。最特殊的地方是和正则表达式（ regular expression,简称 regexp）结合在一起。简单的说她是一种 pattern的表示法，在执行动作，如搜寻或替换时，就会依据这个 pattern去找，所有符合 pattern的地方就会执行您所下的动作。在这个单元里暂不讨论 regexp，会在第十章来探讨，以免搞得头昏脑胀。目前就暂不使用 regexp，您要找什么就直接键入什么就对了。 
5.1 搜寻 
/在 c-mode的情形下，按 /就会在左下方出现一个 /，然后键入您要寻找的字串，
按个 Enter就会开始找。 ?和 /相同，只是 /是向前（下）找， ?则是向后（上）
找。 
n继续寻找。 
N继续寻找（反向）。 
5.2 更方便的搜寻操作（ Vim才有） 
*寻找游标所在处之 word（要完全符合）。 
#同上，但 *是向前（下）找， #则是向后（上）找。 
g*同 *，但部份符合即可。 
g#同 #，但部份符合即可。 n,N之继续寻找键仍适用。 

5.3 替换（ substitute） 
:[range]s/pattern/string/[c,e,g,i]1 
range 指的是范围， 1,7指从第一行至第七行， 1,$指从第一行至最后一行，也 
就是整篇文章，也可以 %代表。还记得吗？ %是目前编辑的文章， # 
是前一次编辑的文章。  
pattern 就是要被替换掉的字串，可以用 regexp来表示。  
string 将 pattern由 string所取代。  
    c  con.rm，每次替换前会询问。  
e 不显示 error。  
g  globe，不询问，整行替换。  
i  ignore不分大小写。  

g大概都是要加的，否则只会替换每一行的第一个符合字串。可以合起来用，如 cgi，表示不分大小写，整行替换，替换前要询问是否替换。 
[实例 ]:%s/Edwin/Edward/g
这样整篇文章的 Edwin就会替换成 Edward。
更进阶的搜寻、替换的例子在说明 regexp的时候还会再详述。目前只知道最基本的用法就可以了！其实光这样就非常好用了。 :-) 
5.4 书签功能
这又是 Vim的一个秘密武器，简单的说，您可以在文章中的某处做个记号（ marks），然后跑到其它地方去编辑，在呼叫这个 mark时又会回到原处。妙吧！ 
mx x代表 26个小写英文字母，这样游标所在处就会被 mark。 
‘x回到书签原设定位置。 ‘是 backwardquote，就是 Tab键上面那一个。 
’x回到书签设定行行首。 ’是 forwardquote，是 Enter键隔壁那一个。
这里举个简单的子，请随便开一个现成的档案，把游标移到任一个位置，然后按 ma做个 mark，再按大写 G移到档尾，然后按 ’a看现在在什么地方？ 
1方括号代表这个设定项是可以省略的，往后的章节同此解释。如果写成 :opt[ion]，表示键入 :opt及 :option两者皆可。 

5.5 Vim对於书签的扩充功能 

5.5.1 小写英文字母

只作用於单一档案内。 

5.5.2 大写英文字母

可作用於各档案间。例如 mA会在 viminfo中纪录下这个档案及位置，结束 vim，然后再启动 vim，按 ’A就会回到当初做标记的那个档案及所在位置 (vim会自动开启做有 A标记的档案 )。别怀疑，请自行马上做个实验就知道啦！ :-) 

5.5.3 阿拉伯数目字

可作用於前次编辑的十个档案。数目字的用法比较特殊， ’0是回到前一次编辑档案中离开前的最后位置， ’1则是回到前二次编辑档案的最后位置，依此类推。您不必使用 m来标示， vim会自动记忆。很玄吧！其实这是 viminfo的功能，您要认真追究的话，请 :h viminfo-.le-marks。viminfo关掉，就没这个功能了！所谓前次指的是前次启动的 vim。不管是哪一种的书签，到达 mark处(或档案 )，想返回原来的位置 (或档案 )，可以按 Ctrl + O。 

5.5.4 :marks

得知目前所有书签的列表。 
  
-----------------------------第5章结束-------------------------------

6 叫档、存档、紧急恢复

ㄟ，是不是在灌水呀！怎么开个档也成一个单元？那您就错了，在 Vim里叫档的花样可多了，而且又可以多档编辑，各编辑中的档案还可以互通讯息，这里面学问可大著呢！ Vim就更骚包了，也学人家档案可以加密，虽说是噱头，但也还满好用的。 
6.1 开档的一些花招 
vim +档名这样开档后，游标会落在档案最后一行的行尾，在档案屁屁后干什么
呢？方便您可以继续编辑嘛！ :-) vim +n档名开档后，游标会落在第 n行的行首。 vim +/string档名还记得吗？ /就是寻找指令，这样进入档案后游标就会落在第一个找到
的 string上，还可以按 n继续找 string哦！喔， string还可以使用 regexp来表示喔。 
6.2 多档编辑
        多档编辑会有两种情形，一种是在进入 vim前所用的参数就是多个档（这种情形称为 argument list）。另一种情形是进入 vim后另外再开其它的档（称为 bu.er list）。不过都可以统称为 bu.er。 
        第 6章叫档、存档、紧急回复 6.2.多档编辑 
:n 编辑下一个档案。  
:2n 编辑下二个档案。  
:N 编辑前一个档案。注意，这种用法只能用於 argument list的情形。  
:e档名 这是在进入 vim后，在不离开 vim的情形下再开其它档案。只要您要 
编辑的档案是在目前目录， Tab补全键还是可以使用。  

        :e#或 Ctrl+.编辑前一个档案，用於两档互相编辑时相当好用。这种用法不管是 argument list或 bu.er list档案间皆可使用。还记得吗？ #代表的是前一次编辑的档案。 
                        :.les或 :buffers或 :ls，会列出目前 bu.er中的所有档案。在 elvis中可使用 :b来叫出 bu.ers。在 bu.ers中，减号 –表示这个 bu.er并未载入，不过，不必担心，载入相当快速的。加号 +表示这个 bu.er已经修改过了。 #代表前一次编辑的档案， %是目前编辑中的档案，这两个代号应该很熟悉了吧！ 
                        :bn bu.er next。编辑次一个 bu.er的档案。 :bp bu.er previous。编辑前一个 bu.er的档案。 :bl bu.er last。编辑 bu.er中最后一个档案。以上两个指令 elvis不适
用。 
:b档名或编号移至该档。
在 :ls中就会出示各档案的编号，这个编号在未离开 vim前是不会变的。这个指令在 elvis也
是可以使用。当然 :e#编号也是可以的，这样的用法则是所有 vi clone都通用了。如果您是使
        用 Vim的 GUI，那就在功能表上就会有 Bu.ers这个选项，可以很容易的知道及移动各 bu.er
间。 
    :bd(elete) 	bu.er在未离开 vim前是不会移除的，可使用这个指令移除。其实移
    除她干什么呢？ vim是您在叫用时才会载入的，因此这些 bu.ers并不
是像 cache一般要占记忆体的。 

:e!档名这样也是会开档，但会放弃目前编辑档案的改变，否则如果档案已有变
动， vim预设是不让您随便离开的。 :e!后不接什么的话，代表舍弃一
切修改，重新载入编辑中档案。 

:f或 Ctrl+g显示目前编辑的档名、是否经过修改及目前游标所在之位置。 
    :f档名改变编辑中的档名。 (.le) 
:r档名在游标所在处插入一个档案内容。 (read) 
:35 r档名将档案插入至 35行之后。 
gf这是 vim的特殊叫档法，会叫出游标所在处的 word为名的档案，当

然，这个档案要在目前目录内，否则会开新档案。哦！好像有点给他复杂，主要原因是偶文笔不好啦！不过您何不选个顺手的来用就可以了，选定了，以后就是使用他，这样就不会那么复杂了。 :-) 
6.3 离开 
:q如本文有修改而没存档，会警告，且无法离开。 (quit) 
:q!舍弃所有修改，强迫离开。 
:wq存档后离开。纵使档案未曾修改也是会再存一次档。 
:x也是存档后离开，但如果档案没有修改，则不会做存档的动作。 
ZZ和 :x完全一样，随您高兴用哪一个。 
:w档名另存他档。不加档名就是写入原档。 (write) 

:q及 :q!是对目前编辑中的档案作用，如果多档编辑的情形并不会离开 vim，这时可下 :qa或 :qa!来整个离开 vim。a就是 all的意思。 :指令 !，这个 !的意思是强迫中止目前正在编辑的动作，而去执行所下的指令。各位应该到目前为止碰过好几次了吧！ 
6.4 Vim的加密功能 
6.4.1 
vim -x [档名 ]

这样进入 vim后会要求输入密码。以后加密过的档案由 vim开启时会自动要求输入密码。否则无法开启。其它的编辑器当然是无法开启的。 

6.4.2进入 
vim编辑档案中，可用 :X指令

小心！ vim一开档就会有个 .档名 .swp这个档，是为了紧急回复用的，一般是在您所开档案的所在目录，这是个隐藏档， ls要有 -a参数才看得到，您加密的功能并没有作用在这个 swp档，因此 root还是知道您在写些什么关於他的坏话的。 :-)当然啦！山不转，路转，路不转，人转，您也是可以把 swap的功能关掉的 :set noswf就行了！但如果您编辑的是大档案，则不建议您把 swap关掉，这样会很吃记忆体的。 
        elvis的话，其暂存档是统一集中存放在 /var/tmp/*.ses，权限是档案所有者始能读写。 Vim的早期版本，其 *.swp档是依原档案的权限来设定的，最近的版本则从善如流，已经改成档案所有人始能读写，就是 -rw——-啦！ 
6.5紧急回复 
vim -r档名，或进入 vim后，下 :recover档名，来回复。 

-----------------------------第6章结束-------------------------------

7 各种标示方法及窗口操作

    这一个章多了一种模式，那便是 visual mode（以下简称 v-mode）v-mode下的反白区（反黑区？ ._.）在本文就统一称为标示区，不知各位是否有更好的中文名称？ㄟㄟㄟ，窗口操作和标示有什么关系？为什么摆在这里说明？ㄚ，是因为这两个单元内容都不多，没地方摆，所以就将就凑在一起的啦！乱点鸳鸯谱就请各位见谅。 

7.1 标示指令 
v 小写 v，这是属於字元标示（ character visual），按下 v后您就可以移动游标， 游标走过的地方就会标示起来。再按一次 v或按 Esc键就会结束 v-mode。  
V 大写 V，这是行标示（ line visual），按下 V后会整行标示起来（包括行首前空白的部分），您移动上下键，会标示多行。再按一次 V或 Esc键就会结束v-mode。  
Ctrl+v 这是区块标示（ blockwise visual），可纵向标示矩形区域。再按一次 Ctrl+v 就会结束 v-mode。结束 v-mode 的方式亦可使用 Esc键，或统一使用  
Ctrl+c。Windows系统下 Ctrl+v是复制键，可以使用 Ctrl+Q来替代。  
d 删除标示区内容。  
y 复制标示区内容。  
c 替换标示区内容。 
标示区内容大小写互换。  
gq 重排标示区内容。请注意，这是要先标示好才按的。 "ay还能不能用呢？当然可 
以，这样就会把标示区内容存於 a缓冲区中。可以用 "ap来贴上。  
Shift+> 标示区内容向右移一个 Tab。  
Shift+< 标示区内容向左移一个 Tab。 

您想更深入吗？ :h visual.txt就有详细的介绍。还有，别忘了有 Tab补全键可以用。 

7.2 窗口操作 

7.2.1 打开和关闭视窗
Ctrl+wn即 :new。开一空的新窗口。这在 Vim会开在原窗口上半方，也就是窗口一分为二。在 elvis GUI界面的话，则是实实在在的另开一个新窗口（可不是另启动一个 elvis喔！），当然 elvis的 console上也是和 Vim一样，窗口一分为二。而且在 elvis下，要放开 Ctrl+w后才按 n，否则 elvis会不鸟您的。凡是窗口操作的按键都是由 Ctrl+w来起头的， w就是 window的意思。 
Ctrl+ws即 :sp(lit)，会开一新窗口，且原档分属两个窗口。 
Ctrl+wf开一新窗口，并编辑游标所在处之 word为档名的档案。 
Ctrl+wq即 :q结束分割出来的窗口。 
Ctrl+wc 关闭当前窗口
Ctrl+wo即 :only!使游标所在之窗口，成为目前唯一显示的窗口其它窗口会隐藏起来。 
Ctrl+w|：把当前窗口横向放到最大
Ctrl+w_：把当前窗口竖向放到最大

7.2.2 在视窗间移动
Ctrl+ww 按顺序在窗口跳转
Ctrl+wj移至下窗口。 
Ctrl+wk移至上窗口。还记得 hjkl的按键移动方式吗？ 
如果您觉得这样分割个窗口来编辑档案不怎么方便，那您可以利用 X下的虚拟桌面，多开个 rxvt + Vim来做多档编辑也是可以的啦！不过这样不仅会多占记忆体，而且 Vim中好用的书签功能就没法使用了。 

7.2.3 移动视窗
Ctrl+wH 即按Ctrl+w再按Shift+h，把当前窗口上移。还记得hjkl的按键移动方式吗？

7.2.4 改变窗口大小
Ctrl+w- 行缩小当前窗口，可在加号前加上数字
Ctrl+w+ 行放大当前窗口，可在减号前加上数字
Ctrl+< 列放大（或缩小，视窗口的位置而定）
Ctrl+> 列缩小（或放大，视窗口的位置而定）
Ctrl+= 平分当前窗口
Ctrl+_ 最大化当前窗口

-----------------------------第7章结束-------------------------------

8 shell命令及求助系统 

8.1 shell命令 
:!外部指令 执行外部指令。当然您的指令要在 $PATH环境变数内。  
:!! 执行前一次执行之外部指令。在这里的 !可不是强迫中止喔！  
@: 这是 Vim的一个很特殊的指令，可以重复前一次的冒号命令。  
:sh(ell) 执行 shell。使用 exit回到 vim。 

这在 Vim GUI会在原窗口内显示执行结果，在 elvis GUI则会另开一 xterm窗口。 console或 xterm下的 vim当然就是跳出 vim进入 shell中。至於是用哪一种 shell是可以另外设定的，可由 :set shell=来设定。
另外，在此补充一下补全的功能。不是只有 Tab键的补全功能喔！也可以使用上下方向键，叫出历史指令，叫出历史指令可用於冒号命令及寻找命令（ /）。例如，您前已下了 :!ps aux这个指令，您可以按 :后就直接按向上方向键。别忘了！寻找指令也是可以这样用喔！ 
:r !commond这个就妙了！会在游标所在处次一行插入外部指令 commond执行后的输出内容。例如 :r !date就会插入日期时间。这在 elvis是会插入在游标所在处那一行。 
:n,mw !commond以 n至 m行内之资料，当做外部指令 commond的 input。这算是相当高级的用法了，初学者大概还用不上，不过印象中留有一个这样的功能，以后总是会用得上的。 
K大写 K会显示游标所在处之 word的 man page系统线上使用手册。 

8.2 求助系统
原始 vi是没有 on-line help的，但 Vim及 elvis则有相当丰富的说明系统。 Vim沿用传统 
        第 8章 shell命令及求助系统 8.2.求助系统 
tag的方式来找主题，而 elvis就高明了，是使用 HTML的格式。原来 elvis是可以直接阅读 HTML档的，当然不能显示图档，但会标明图档的名称。
        用过 pe2(3)吗？好像 F1是救助键已让大家公认。 Vim预设按 F1就会叫出说明档。 elvis当然没有，不过您可以自行设定，在 /.elvislib/elvis.rc中加上 
    map #1 :help.M
                就可以了。须注意的是 .M是按 Ctrl+v后不放再按 M或 Enter键，表示马上执行。ㄟ， .M是特殊字元，是一个字元，而不是两个字元，您移动游标在 .M上就知道了，不是我文中的，文中的是直接打出来的两字元 .M。在 console下要打特殊字元的话，要 Ctrl+Shift+v然后按您要的键。 
        :h name这样就会叫出 name这个说明档，如果后面没接 name，则会叫出 help.txt这个总说明档（在 evlis是 elvis.html） h是 help的缩写。ㄟ， name记不清楚时，别忘了 Tab补全。在 Vim的说明档中，遇有两个 |围住的主题，把游标移到上面就可以使用 Ctrl+]来叫出这个主题的说明， Ctrl+t可以回到原来的地方。 elvis中也是可以这样用。 :q可结束说明档，回到原编辑档案。 
:ver会显示版本、编译资讯，编译时加入之参数也会显示出来，让您知道有加入些什么功能，因为有些功能在编译时就得加入。其中正号 +表示有此功能，减号 –表示无此功能。 elvis/nvi只能显示版本资讯，无法显示编译资讯。 1
    在此补充说明一点，各位有没有觉得 :q很常用到，好了！就依 pe2的习惯设为 F4吧！怎么设？找上面叫出说明档怎么设，您就依样画葫芦就可以了！ Vim的设定档在 /.vimrc。个人是直接设成 :q!以免麻烦，但要记得存档喔！ 
1个人都会编译出一个全功能的 vim来备用，而且 GUI及 console下使用的各编一个，以加快 console下的启动速度。 

-----------------------------第8章结束-------------------------------

9 set功能设定

本单元可说是 Vim的微调功能，可依您个人的喜好做有限度的调整。由於 Vim做了相当多的扩充，文内主要是述叙 Vim的设定，但 elvis没有的也会标明。但并不打算一网打尽，只说明重要、常用的部份，其它的可以 :h option-list来查阅。
    在系统上，会有个 vimrc_example.vim档，可以依据这个档案来设定一些常要用到的内容。 

9.1 该在何处设定呢？ 

9.1.1 Vim的设定档
可在线上做设定，例如 :set ai或 :set noai，ai是 autoindent的缩写，这样就可以马上改变缩格的设定，但离开 vim后就又恢复原状。要永久设定就得设在设定档中。 vim的设定档在： 
    ~/.exrc 
    ~/.vimrc 
    ~/.gvimrc GUI版本 
$VIM/vimrc系统预设值，最好不去修改 
$VIM/gvimrc GUI版本 
$VIM\_vimrc Windows版本 
$VIM\_gvimrc
                您要把 GUI的设定设在 $HOME/.vimrc也是可以的，但分开来可能对以后要修改时会比较找得到地方改。那 $VIM在哪里呢？ /usr/share/vim或 /usr/local/share/vim这是编译时就决定的，但可在 $HOME/.bash_profie或 $HOME/.bashrc中另设。 Windows版本的 $VIM则在 C:\Vim这个目录中，亦可设在 autoexec.bat中。 

9.1.2 elvis的设定档 
    ~/.exrc 
        ~/.elvislib/elvis.rc 
    C:\Program Files\elvis\elvis.rc Windows版本
        如果您的系统上同时有 Vim及 elvis，则使用 $HOME/.exrc要小心，以免互相影响了设定。好处是可以把共同的设定设在 $HOME/.exrc里。提醒您一下！设在设定档中时 set前当然是不必冒号的。 

9.1.3 nvi-m17n的设定档 
    ~/.exrc 
    ~/.nexrc 

9.2如何得知目前的设定 
:set或 :se 会显示所有经过修改的部份，就是和预设值不一样的部份。  
:set all 显示目前所有设定值内容。  
:scriptnames 显示各种设定档的所在路径及其档名。  
:set option? 显示 option这设定的目前值。  
:option 直接线上设定，有些设定需加 =后加上设定值内容。  
:set nooption 取消该设定。 :set后面是可以多重设定的。例如  

:set autoindent noconfirm autowrite，这样三种设定就会同时重设。
您当然可以改设定档来改变设定值。在 Vim也可以使用 :opt[ion]来直接线上设定，会列出目前的设定，在 set这个字上按 Enter即可改变设定，或就直接修改其值亦可，改完后按 :q就可以了。在简短说明处按 Enter则会叫出该部份的说明档给您参考，您说方不方便？改好后 
    :mk[exrc]则会写入 ~/.exrc档 
    :mkv[imrc]则会写入 ~/.vimrc档
                当然您得先搞清楚您目前所在目录在什么地方，如果您是在家目录启动的那就不用担心了，否则找不到您的新 .vimrc可不要写信来骂我。 :-) elvis可就没这么方便了，得自行修改 $HOME/.exrc或 $HOME/.elvislib/elvis.rc。 

9.3 各种set功能说明
方括号内的是缩写，由於 Vim新增的指令、设定项实在是相当多，建议一开始使用完整的写法，等熟悉后再来使用缩写会比较好。 
autoindent[ai]
自动缩排，也就是说如果本行是从第五个字元开始写的，您按 Enter后游标就会停在次行第五个字元处。预设是不打开的。 
autowrite[aw]
档案一有更动就会自动存档。预设不打开。 
background[bg]（Vim才有）
                                可设成 dark或 light，这是两种不同的 highlight颜色设定，系统预设的内容是在一个 synload.vim档中，详见 $VIMRUNTIME/syntax/synload.vim。不过您要更动颜色的设定，最好是设在 $HOME/.vimrc或 $HOME/.gvimrc中，原始档预设档尽量不要去动她。ㄟㄟㄟ，你从没提过 $VIMRUNTIME好不好！其实这是最近版本的 Vim为了不至安装新版本时把旧版本的一些设定或 macro档干掉，所以 $VIMRUNTIME就是 $VIM/vimxx，xx就是版本号码啦！例如您使用的是 Vim 6.1版，那么就是 $VIM/vim61，往后安装 6.2版时，会把 runtime .les装在 $VIM/vim62，这样就不会把旧的 runtime .les给盖掉。 
backup[bk]
    是否要 backup .le。预设不打开。 
writebackup[wb]（Vim才有）
在写入档案前先备份一份，和 backup的作用不尽相同，请 :h backup-table。预设是打开的，所以您如果不要 backup，那要关掉的是这个项目，而不是 backup。但请先检查一下您编译时是不是有编译进去，请 :ver。 
backupdir[bdir]（Vim才有）
    设定存放 backup .le的目录。预设在所编辑的档案之所在目录。 
        第 9章 set功能设定 9.3.各种 SET功能说明 
binary[bin]（Vim才有）
    设在编辑二进位档状态，这是防止存二进位档时把 EOL也写进二进位档，那就会悔不当初，如果是图档将会无法再观看，如果是可执行档就无法执行了！因此预设是 o.。elvis会自动判断是否为二进位档，而且会分成左右两半，左半部会以 16进位的方式显示，右半部则是以 ASCII的方式来显示。 
browsedir[bsdir]（Vim才有）
浏览档案的目录， GUI版本始有。预设是上一次浏览的目录。就是 GUI版本功能表上的 [File] 
. [Open]会打开的目录。 
cindent[cin]（Vim才有）
    写 C时很好用， indent比一般敏感，专为 C程式码而设。预设 o.。编辑 C/C++ code时会自动打开。 
cmdheight[ch]（Vim才有）
状态列的行数，预设一行，建议设成两行。 
compatible[cp]（Vim才有）
    设为和原始 vi相容的状态， vim的扩充功能会被抑制。预设 o.。 
    con.rm[cf]（Vim才有）
    各种确认动作。预设 o.。 
directory[dir] 
swap档存放的目录。前面单元已有说明。 
.leformat[ff]（Vim才有）
这是写入档案时置放 EOL(end of line)的形式 
dos是以 0x0D0A来断行。 
unix是以 0x0A来断行。 
mac是以 0x0D来断行。

预设以各系统平台而定，在 Linux当然是 unix形式。 
.leformats[ffs]（Vim才有）
    可指定多个，会依载入的档案形式来调整 .。例如 :set ffs=unix,dos ff=unix
                                    则预设为 unix格式，但如读入的是 dos格式的档案，会自动调整为 dos格式，这样存档时就会以 dos格式存档（状态列会显示）。。此时如要改成 unix格式，可 :set ff=unix然后存档就会转成 unix格式，反之亦然。如果不这样设，也就是您不管 .或 .s都设成 unix，那读入 dos格式的档案时在每行尾会出现 .M这个字元（就是 0x0D啦！）这时纵使 :set ff=unix也来不及了！只好 :%s/.M//g来消去这个 .M。ㄟ，还记得怎么替换吗？就是把 .M换成没有啦！而且 .M怎么打出来的还记得吧！翻一翻前面的单元吧！ Hey，你怎么知道是 0x0D呀！好吧！告诉您一个密秘，您把游标移到 .M那个位置，然后按 ga在状态列就会显示 10，16，8进位的值。其它的字元也是可以如此显示。 a就是 ascii的意思。但这是 Vim的扩充功能， elvis没有。 elvis纵使载入 dos格式的档案，也是会自动把 .M隐藏起来。 
ignorecase[ic]
    寻找时不分大小写，这对中文会造成困扰。预设 o.。 
incsearch[is]（Vim才有）
    加强式寻找功能，在键入 patern时会立即反应移动至目前键入之 patern上。预设 o.。 
hlsearch[hls]（Vim才有）
    寻找时，符合字串会反白表示。预设 o.。如果您是使用 vim的预设的 vimrc档的话，可设在 F8键来切换。 
textwidth[tw]
是一种 wordwrap的功能，从左起算之固定每行的最大字元宽度。超过此宽度就会自动折行，这可是真的折行，也就是说在折行处会插入 EOL。预设是 0，也就是没有 wordwrap的功能。 
wrapmargin[wm] 和 textwidth作用相同，只是是从右窗口边向左算起要几个字元起折行。预设是 0。 
wrap 这也是折行功能，可是只是萤幕效果的折行，实际上并没有插入 EOL。 
wrapscan[ws]
这和折行没有关系，是指寻找时，找至档尾时，是否要从档首继续找。预设是要。 
paste（Vim才有）
这是防止在做剪贴时位置会不正确，前面单元已有说明。 
ruler[ru]（Vim才有）
会在状态列显示游标所在处之行列状态，预设不打开，但建议打开。最右边之代号的意义如下： 
Top档案第一行在萤幕可见范围。 
Bot档案最后一行在萤幕可见范围。 
All档案首尾皆在一个萤幕范围内。

如非以上三种情形，则会显示相对百分比位置。 
statusline[stl]（Vim才有）
状态列显示的格式，使用预设就可以了，如果您想骚包一下的话，那就请您 :h stl。 
shiftwidth[sw]
    指由 .移动整行内容时，一次移动的字元宽度，一般是使用 Tab的值，但可由这个设定来改变。 
tabstop[ts]
一个 Tab键宽度。预设是 8个字元宽度。最好不要随便改，以免您写的东西由其它编辑器来阅读时造成困扰，为解决这个问题， Vim另有种 softtabstop及 modeline的机制，在以下各节会详细说明。 
showcmd[sc]
在状态列显示目前所执行的指令，未完成的指令片段亦会显示出来。 
showmode[smd]
在状态列显示目前的模式，例如是 Insert mode或是 Visual mode。当然平常的 normal mode(commond mode)是不显示的。在载入档案的同时，会在这个地方显示档案名称及其总行数、总字元数。 
visualbell[vb]（Vim才有）
以萤幕闪动代替 beep声。 
number[nu]
显示行号。注意，冒号命令也有 :nu这是显示游标所在行的行号，您嫌多打一个字的话， :#也行。不过如果 ruler打开的话，在状态列本就会显示门前游标所在处的行列值。 
list
    这也可以算是一种模式， list mode。就是 Tab的地方会以 .I显示，而行尾之 EOL会显示成 $。可以让您清楚的知道 Tab在哪里，折行是不是真的。 
    swap.le[swf]（Vim才有）
        是否需 swap至磁碟。如果设为 noswf的话，那将不会有 swap.le产生，通通会载入在记忆体中。预设是要 swap.le。 
.leencoding[fe]（Vim才有）
        首先，先鼓掌一下，啪啪啪 ······，因为有支援 Taiwan，也支援 XIM，也就是说可以使用 xcin-2.5x来作输入，当然您用 xcin-2.3x配合 XA也是可以啦！但前提是您要把 multi_byte编译进去，这在一开始就讲过了。预设是使用 ansi。set guifont及 set guifontset已在一开始讲过，在此就不重复了。 
history[hi]
记录冒号命令的历史纪录档，就是可以用上下方向键叫出来的那锅。预设是 20笔。 
        第 9章 set功能设定 9.4.关於 SOFTTABSTOP[STS] 
9.4 关於 softtabstop[sts]
几乎所有的 OS及软体都设定 Tab就是 8个字元长，这已经是个公认值，您硬要去改变它的话恐怕带来许多不便，但实际上关於程式风格，许多人又认为 8个字元太长了，几个巢状回圈下来就需折行，反而不方便。因此 Vim体贴您，内建了 softtabstop的功能，就是由 Vim来代您制造出一个假的 Tab，实际上是空白字元组成的 Tab。
举个例子来说明比较清楚。 
set softtabstop=4 
set shiftwidth=4
这样会由 4个空白字元取代一个 Tab，您按 Tab键 vim就跳 4格，需注意的是，如果您按了三次 Tab键，那就是一个实际的 Tab加上四个空白字元，可不是 12个空白字元喔！是混合 Tab及 Space的。
问题来了！那我要按真正的 8字元的 Tab时怎么办？简单，还记得怎么按特殊字元吗？ Ctrl+v Tab或 Ctrl+v I就可以了，那就是如假包换的 8字元长之 Tab。当然，您按两次 Tab不就得了！ :-)
    另一个更大的问题也来了！在 Un*x系统的有些设定档，例如 Make.le, snedmail的设定档，他们会认真正的 Tab，因此如果您有程式开发或系统管理的需要的话，最好是不要随意更动 Tab值，也不要使用 softtabstop，可以使用 Vim独特的 modeline来控制，请继续研读下一节。 

9.5 Vim的 modeline
这个是什么哇？简单的说， Vim有能力去解读所编辑档案内的 Vim控制参数，而这些控制参数是写在档案的注解行里头的，例如 sh script的注解行是以 #来开头的，那 Vim的控制参数就可以写在这些注解里头， Vim在开这个档的同时，也会去控制自己的一些行为，当然，包括了上一节所说的 Tab的长短，而 shell本身则会忽略这些注解。
例如，现在把一个 sh script档里头，在档案最后一行，设了个： 
# vim: ts=2
这样一来，按个 Tab，实际上显示出来会只有两个空格，别担心仍然是正港 Tab，不相信的话，可用另一种编辑器打开就知道了。这个好用吧！详细请进入 vim后 :h modeline。 
        第 9章 set功能设定 9.6.关於折行
当然，这个功能很方便，但并不是全然没有限制的，以下有些限制要注意： 
1.控制 
modeline本身的设定，不能写在档案里头， vim会来不及读他。
例如：在 sh script档案中设定 # vim: set modelines=0这是行
不通的。 


2.
这些设定必须要在档案的开头五行，或结尾五行内设定，否则 vim会忽略。 

3.
注解符号后要至少一个空白 (sapce或 Tab皆可 )隔开。例如： 
/* vim:noai:sw=3 ts=4 */ => C程式码 /*和 vim间至少要有个空白 
// vim:ts=2 => C++ 
# vim:ts=2 => sh script, perl, python, tcl 
" vim:ts=2 => vim script 



9.6 关於折行
前面已说过 set wrap就可以造成萤幕折行，可是却会把一个英文单字折成两半，实在很不雅观。好了， Vim再体贴您一次， :set linebreak(lbr)就会避免这种问题发生，会在空白或标点符号的地方来折行，但也仍属萤幕折行，并不会插入 EOL。
在一般的文书排版处理，甚至是写程式码，设定系统的设定档，这些时机，可能自动折行并不很适合 (指会插入 EOL的)，很容易把写好的内容，因为一个不小心就都弄乱了，因为程式一般是一行一行在读的，把一整行分成两半，所读的结果就不一样了，除非加入程式码的折行标志，例如一般的倒斜线 1 \或 TEX/LATEX的百分号 %。而在排版软体如 TEX/LATEX，插入 EOL的折行，会造成中文字间多出个空白，这在 HTML格式的档案亦同，因此，在做折行的决定时，也请考虑一下其他的『副作用』。 

9.7 我的设定档
以下是我个人的设定档，仅供参考用： 

9.7.1 .vimrc范例 
            " ~/.vimrc by Edward G.J. Lee 
"这个记号就是 vim的注解，通常情形 vim会忽略。 
" This code is Public Domain 
" 
set backspace=indent,eol,start 
1Vim script的折行标志也是倒斜线，但这个倒斜线不是像一般 script一样放在本行的最后，而是放在次一行的开头处，请小心不要放错了。 
set autoindent " always set autoindenting on set history=50 " keep 50 lines of command line history set ruler " show the cursor position all the time set showcmd " display incomplete commands 
set enc=big5 "档案编码设成 big5 
"使用 :update代替 :w，以便在有修改时才会存档，注意，这和 vi不相容。 map <F2> :up<CR> map <F3> :up<CR>:q<CR> "存档后离开 map <F4> :q!<CR> "不存档离开 map <F5> :bp<CR> "前一个 buffer档案 map <F6> :bn<CR> "下一个 buffer档案 "单键 <F7>控制 syntax on/off。倒斜线是 Vim script的折行标志 "按一次 <F7>是 on的话，再按一次则是 off，再按一次又是 on。 "原因是有时候颜色太多会妨碍阅读。 map <F7> :if exists("syntax_on") <BAR> 
\ syntax off <BAR><CR> 
\ else <BAR> 
\ syntax enable <BAR> 
\ endif <CR> 

"按 F8会在 searching highlight及非 highlight间切换 
map <F8> :set hls!<BAR>set hls?<CR> 
" Toggle on/off paste mode 
map <F9> :set paste!<BAr>set paste?<CR> 
set pastetoggle=<F9> 

map <F10> <ESC>:read !date<CR> "插入日期 
map <F11> :%!xxd<CR> "呼叫 xxd做 16进位显示 
map <F12> :%!xxd -r<CR> "回复正常显示 

"Default backspace like normal 
set bs=2 

    "Display a status-bar. 
"set laststatus=2 

    "Show matching parenthese. 
set showmatch 

"以下是颜色设定，详细请 :h hi 
hi Comment term=bold ctermfg=darkcyan 
hi Constant term=underline ctermfg=Red 
hi Special term=bold ctermfg=Magenta 
hi Identifier term=underline ctermfg=cyan 
hi Statement term=bold ctermfg=Brown 
hi PreProc term=bold ctermfg=DarkYellow 

        第 9章 set功能设定 	9.7.我的设定档 
hi Type term=bold ctermfg=DarkGreen 
hi Ignore ctermfg=white 
hi Error term=reverse ctermbg=Red ctermfg=White 
hi Todo term=standout ctermbg=Yellow ctermfg=Red 
hi Search term=standout ctermbg=Yellow ctermfg=Black 
hi ErrorMsg term=reverse ctermbg=Red ctermfg=White 
hi StatusLine ctermfg=darkblue ctermbg=gray 
hi StatusLineNC ctermfg=brown ctermbg=darkblue 

    set viminfo=’20,\"50 	" read/write a .viminfo file, don’t store more " than 50 lines of registers 
"方便中文重排设定 
set formatoptions=mtcql 

"设定 modeline 
" vim: ts=2: 

9.7.2 .gvimrc范例 
            " ~/.gvimrc by Edward G.J. Lee 
" This code is Public Domain 
" 
set mousehide "当输入文字时隐藏 mouse 
map <S-Insert> <MiddleMouse> 
map! <S-Insert> <MiddleMouse> 

        " Only do this for Vim version 5.0 and later. 
if version >= 500 
let c_comment_strings=1 
if !exists("syntax_on") 

syntax on 
endif 

hi Comment guifg=DarkBlue hi Constant gui=bold guifg=Magenta guibg=#fffff5f2eed8 hi Special guifg=Blue guibg=#fffff5f2eed8 hi Identifier gui=bold guifg=DarkCyan hi Statement gui=bold guifg=brown hi PreProc gui=bold guifg=black hi Type guifg=darkgreen hi Ignore guifg=bg hi Error guibg=Red gui=bold guifg=White hi Todo guifg=Blue guibg=Yellow hi ErrorMsg guibg=Red gui=bold guifg=White hi Normal guibg=#fffff5f2eed8 hi ModeMsg guifg=DarkBlue guibg=yellow 
        第 9章 set功能设定 9.7.我的设定档 
hi StatusLine gui=bold guifg=lightgray guibg=DarkBlue 
hi StatusLineNC gui=bold guifg=lightgray guibg=brown 
hi Cursor guibg=green guifg=NONE 
hi lCursor guibg=Cyan guifg=NONE 

endif 
"让 ex(:) mode时可以输入中文 (gvim) 
set imcmdline 
"让 xcin在 insert mode不自动出现 (gvim) 
set imdisable 

9.7.3 .vim目录范例
其实，一些设定档除了家目录下的 .vimrc及 .gvimrc外，可以置放於家目录下的一个子目录 .vim，其目录结构可以仿 $VIMRUNTIME这个系统上的结构。例如，我的 .vim结构如下： 
    edt1023:~$ tree .vim 
.vim 
    |--filetype.vim 
|--plugin 
    | |--format.vim 
    | ‘--tex.vim 
|--syntax 
    | |--lily.vim 
    | ‘--svg.vim 
‘--view 

    ‘--~=+bg5.txt= 
    3 directories, 6 files
                                其中， filetype.vim会在系统的 filetype.vim载入后盖过去，也就是家目录的会先优使用。 format.vim及 tex.vim是进入 vim马上会载入的 Vim script，主要用於中文重排及 TEX/LATEX排版系统编辑时的方便指令、按键。 lily.vim则是 GNU LilyPond这个乐谱排版系统档案的语法颜色定义档， svg.vim则是 SVG向量图档的语法颜色定档加强版。那 view那个子目录下的又是什么呢？这是下 :mkview指令时所存的一些状态档，在 :loadview要参考到，请参考第 11章，第 11.1.3小节，页 51，这个档是个隐藏档。 

-----------------------------第9章结束-------------------------------

10 正则表达式的运用

在本系列文章一开始就说明了学 Vim可以顺便学正则表达式（ regular expression，以下简称 regexp），那为什么到现在才来讲呢？因为 regexp说简单也算不很难，但您要深入去使用的话，有时会马上看不出一个复杂的 regexp在说些什么的，就曾有人形容 regexp为「有字天书」！而且在 Vim整体都还没一个概念就加入 regexp的话，那后面的单元恐怕就没人看了！而 regexp各家有各家的 extensions，这也是大家视为畏途的原因之一，不过总是大同小异，只需注意一下就可以了。
目前先不必管别家怎么说，就让 Vim暂时先成为我们的「标准」，以后碰到其它程式的 regexp应该就可以触类旁通。以下我们尽量由实例去了解。当然，小小的一篇文章是没有办法详尽介绍，只能捡重点来说明了。如有疑问，可 :h pattern或在 Un*x系统中可 man 7 regex，甚至 man ed，man sed，man grep，man awk，man perlre里面也是会说些 regexp，但要注意和 Vim差异的地方！其中 perl的 regexp应该是最完整的了，如果您的系统没有 perl那应该是「稀有动物」了！ :-)ㄟㄟㄟ！ Vim只是一个编辑器，可不是独立的程式语言 (虽然，内建的 Vim script是有点好用 )！ 

10.1 基本的匹配 
* 指前所绑住的字元或字元集合，出现 0次或 0次以上。  
\+ 和 *作用相同，但不包括出现 0次。  
\= 指前所绑住的字元恰好出现 0或 1次。  
\| 这是多选，就是 or的意思，被 \|隔开的 pattern，任一个符合的话就算符合。  

\+, \=, \|会加上一个 \，是因该字元在 Vim就具有特殊意义，在一般的 regexp中是 +, ?, |就可以了，只是提醒您一下，以免搞混了！记住 \+是不可数的！用辞不是很精确，只是帮助您记忆啦！在 elvis及 ed中是使用 \?来匹配出现 0或 1次，而不是 \=，这里要非常小心！ 
[实例 ]dg*指 *前所绑住的字元 g出现 0次或 0次以上。也就是说 d(出现 0次)，dg, dgggg, dgggggggg都是符合这个 pattern。如果您下寻找指令 /dg*，那符合这个 pattern的字串都会被找出来。如果用在代换就要非常小心了，像 extended中的 d也是会被置换掉的。例如您下 :%s/dg*/test/g的话，那 extended这个字会换成 extentestetest。 
shell中使用的通用字元为 pattern matching notation和 regexp是不同的意思。 dg*在 shell中是解为以 dg开头的任意字串，这就不包括 d在内了，也就是说在 shell中， *是代表任一字元或字串，这在初接触的朋友很容易就搞混，请千万小心。 
[实例 ]dg\+ dg, dgg, dgggggg皆符合，但 d则不符合。如果是 dg\=的话，就只有 d、dg这两个符合了。 
[实例 ]:%s/The\|All/test/g全文中只要是 The或 All都会被替换成 test。注意，如果文中有 There也是会被替换成 testre！要如何避免这种情形呢？下面会另述及限定使用法。 
[实例 ]/123-\=4567这样会找出， 123–4567及 1234567。当然 123–456789也是会被找出来。 
            [...] 字元集合，表示中括号中所有字元中的其中一个。  
                        [...] 这是上述 [.. . ]的补集，表非中括号内字元的其中一个。  
. 除换行字元外的任一单一字元。指本身，非指前所绑之字元。就好像 shell中的 ? 
        一样。如果要指定真正的英文句点，要用 \来 escape，就是说 \.这时的 .是代表真 
正句点，而不是 regexp中的特殊意义。其他如 \*亦同。  

[实例 ] 
[Aa] 
A或 a其中的一个。 
[12345] 
12345其中的一个数目字。可用 [1–5]来表示。连续性的数目字或字元可用 –来隔开，写出头尾来代表就可以了。 [0–9]就表 0到 9的数目字， [a–d]就代表 abcd四个英文字母 
[实例 ]W[0-9]*\.cc这个例子是说以 W开头，后接 0–9其中一个或多个数目字或不接什么，然后是一个句点，最后是 cc。所以 W.cc，W1.cc，W2.cc，W345.cc，W8976543287.cc皆符合。如果要表示 W及 .cc间夹一个以上的数目字，要写成 W[0-9][0-9]*\.cc。 
    [实例 ].*这代表任意字元或字串，或什么都没有，脑筋急转弯，对照前面的定义想一下。当然这是不包括换行字元的。 
[实例 ] 
    [.M]　表除 M以外的任意字元。 
    [.Tt]　表 T及 t以外的任意字元。 
    [.0-9]　表非数目字之字元。 
    [.a-zA-Z]　表非英文字母之字元。

                    注意， .要在中括号内，且在最开头的地方，否则另有含意。 .匹配行首，指其后绑住的字串，出现在行首才符合。 $匹配行尾，指其前绑住的字串，出现在行尾才符合。含换行字元。不是在行首的 .指的是 .这个字元。不是在行尾的 $是指 $本身这个字元。 [实例 ]/.What这样只有在行首的 What才会被找出来。注意！ Whatever, What’s也是会被找出来。如果是 /What$则是在行尾的 What才会被找出来。 
    [实例 ].$这是什么东东？行首也是行尾的行。ㄚ，就是空白行嘛！当然也不能说这个行是没有什么东东啦！空白行至少也是会有个换行字元。在后面会详述如何消除全文的空白行。 
                        \(...\)记忆 pattern，可由 \1, \2. . . \9来叫出。 
                                                [实例 ]:%s/\([a-z]\)\1/test/g这样 aa, bb, cc, dd,. . . zz都会被 test替换掉。这和 :%s/[a-z][a-z]/test/g是不一样的意思，后者会把 aa,ab, ac...ba,bb,bc...zz都换成 test。也就是说 \(...\)由 \1叫出时会有对称性的配对出现。 
[实例 ]:%s/\(.\)\(.\)r\2\1/test/g
会将中间为 r，前有二个任一字元，后有两个具对称性的字元所组成的字串替换成 
        test。\2是呼叫第二组 \(.\)，而 \1是呼叫第一组 \(.\)。例如： 12r21，cfrfc，7grg7等
都会被替换成 test。 
\<匹配字（ word）首。所谓 word包括文数字及底线。 
\>匹配字尾。这就是前所提及的限定用法，被 \<，或 \>括住的 pattern就会被限制
    住，使 regexp不能再向右（左）扩充解释。 ed及 perl中可以 >b来表示这两个符号， perl中只支援 >b，ed则 >b及 \<, \>皆支援。但在 perl可多加个 ?来限制 regexp的扩充解译。功能上而言，这是和 .$一样的定位样式（ anchor pattern）指所绑住的字串必须是单字边界（ wordboundary），前或后或前后除了空白字元及标点符号外不可再有其它字元。在 Vim中 \b是表示 <BS>即 Backspace键。 
[实例 ]:%s/\<abbbc\>/test/g
这样只有 abbbc才会被替换成 test。如果没有这样限定， :%s/abbbc/test/g，那 
deabbbcly中的 “abbbc”亦会被替换成 test。所以前面 :%s/The\<All/test/g可换
成 :%s/\<The\>\|\<All\>/test/g这样一来， There就不会被替换成 testre了！ 
[实例 ]:%s/\<abbbc/test/g这样的话，只要是以 abbbc为首的字 (word)，其中
的 abbbc的部份都会被 test所替换。注意！是指字首，而不是指行首。所以 
abbbc，abbbcerd，abbbckijuds都符合。 
\{n,m}指前所绑住的字元或字元集合最少出现 n次，最多出现 m次。
这在一般的 regexp表示成 \{n,m\}。Vim及 elvis两种表示法皆支援。 perl则直接使用 {}。以
下会举四种不同的例子，请大家发挥一下想像力。 :-) 
[实例 ]\{最小值，最大值 }
如 [0–9]\{3,4}匹配至少三位数，但不可多於四位数的数目字。如： 
123 
12 
1 
123456 
1234567 
12345678 
1234 
12345 
    如果下 :%s/[0-9]\{3,4}/test/g的话，那 1，12这两组不会被替换，因为不满 3位数。而 12345，则会换成 test5。123456，则会换成 test56。12345678，则会换成 testtest。1234567也是会换成 testtest。123，1234这两组则会被替换成 test。您可以亲自操作一次就知道怎么一回事了。操作时最后加 gc来 con.rm，这样您会更了解实际替换的内容。ㄟ，别忘了 u可以回复您的编辑动作。 
[实例 ]\{数目字 } 
xy\{20}　表示 x后接 20个 y。 e[x-z]\{4}　表示 e后接有四个字元，是 x,y,z的其中
一个的组合。如： exxxx, exyyz, ezzyz, exyzz皆符合。 

[实例 ]\{最小值， } 
xy\{2,}　表 x后接至少二个的 y。相当於 xyyy*或 xyy\+。 

[实例 ]\{，最大值 } 
xy\{,4}　表 x后接至多四个或更少的 y（可能没有）。因此 x, xy, xyy ,xyyy, xyyyy
皆符合。 

10.2 中介字元（ metacharacter, or character classes）
主要是简化 regexp的书写。 
\s表空白字元，即 Space或 Tab。 
\S表非空白字元。 
\d表数目字（ digits），即 [0–9]。 
    \D表非数目字，即 [.0–9]。 
\w表一般字元（ wordcharacter），包括底线。即 [0–9a–zA–Z_]。 
    \W表非一般字元，即 [.0–9a–zA–Z_]。 
\a表英文字母（ alphabetic character），即 [a–zA–Z]。 
    \A表非英文字母，即 [.a–zA–Z]。 
\l表小写字母（ lowercase character），即 [a–z]。 
    \L表非小写字母，即 [.a–z]。 
\u表大写字母（ uppercase），即 [A–Z]。 
    \U表非大写字母，即 [.A–Z]。

原始 vi不支援此种中介字元。使用中介字元的比对速度将会比使用字元集合 []的快。 

10.3 全域性的指令 
:[range]g/pattern/[cmd] 
cmd是 ed可用的指令，预设是 p(print)，您可查一下 man ed，就可以知道有什么指令可用。这个小节里主要是说明 d(delete)的功能。因为是要说明如何消除空白行。需注意的是， d是行删除指令，凡含 pattern的整行都会被删掉，而且 range不指定的话，预设是全篇文章，因为 g就是代表 globe。
在 Vim的 help档里说的是 ex指令，但 ex实际上是和 Vim连结的，因此这里特别指出 ed。但 ed的指令少数可能会和 Vim的 ex不同，这是因为 ed和 Vim并非同步在发展，作者也非同一人。 
    :g/.$/d
    这样就会删除全文的空白行。前面已提过 .$代表的是空白行。但这里有个问题，如果空白行里包含了其它空白字元（即 Space或 Tab）的话。表面看起来是和一般空白行一模一样，但却暗藏玄机，用上面的方法就无法删除这种空白行了！怎么办？来！看招！ 
:g/^[<Space><Tab>]*$/d
在 Vim或 elvis里您可以如此照打，也就是 <Space>代表空白字元， <Tab>代表按 Tab键的结果。在原始 vi则不行，得自行按出特殊字元出来，就是 Ctrl+v Space及 Ctrl+v Tab。或采更简单的打法： 
:g/^\s*$/d
还记得中介中元吗？好用吧！少打了不少字。 :-)意思就是删除含 0或 1个以上空白字元的行。
    有些书中写成 :%s/.$//g可以删除空白行，这是错误的，因为 :s这个指令只更动一行里的内容物，但不会做删除一行的动作。 

10.4 &替代变数
代表置换时合於 patern的字元或字串。 
    [实例 ]:%s/.\d\d\d\d\d\d\d\d\d\>/ID:&/g
这样全文中的身份证字号前就会加上 ID:字样，也就是说 T123456789会被换成 
ID:T123456789。还记得吗？ \d就是 [0-9]，\u代表大写的英文字母。加个 \>是防止 
T12345678999也被换掉。当然前面再加个 \<更保险。 ID:字样您用中文也行！另一个
好用的例子是电话号码前加上 TeL:，就请您自行练习了！ 

[实例 ]将档案 3至 7行的资料向右移 2个空白 
    :3,7s/.*/ &/
但这样连空白行也是会插入空白字元，较高明的做法是： 
    :3,7s/.\+/ &/
            这样空白行就不会去动它了！想通了 .*及 .\+的意思了吗？往前翻一下 .* \+的定义。 
[实例 ]将档案 3至 7行的资料向左移 2个空白 
    :3,7s/. //
就是删去行首的二个空白啦！ 
[实例 ]将全文的 Edward这个单字，前后加上中括号 
:%s/\<Edward\>/[&]/g 
[实例 ]将全文的 Edward这个单字，改成大写的。 
:%s/\<Edward\>/\U&/g
    ㄟ！ \U不是代表非大写字母吗？喔！您搞错位置了。 \U在 pattern的位置的时候是指非大写字母的样式，即 [.A–Z]，但如果是在置换字串位置的时候是指将其后的字串通通改成大写。与其相对的是 \L，会将其后的字串改为小写。详细请 :h sub-replace-special。 
[实例 ]将全文每行最后加上 <BR>这个 HTML tag。 
    :%s/.*/&<BR>/g
怎么样，是否已感觉到 regexp威力无穷了呢？还是您已经快睡著了呢？ :-)不过也请您想想，如果是在没有 regexp功能的编辑器里，范例中的一些动作您会怎么做呢？一个一个去改？ 
10.5 greedy陷阱 
    regexp会有贪心的倾向，什么意思呢？就是说在同一行内，如果有多个符合 pattern的情形，会找最长的那一个。请注意！ greedy的特性是针对会反覆比对的 regexp而言，例如： *, \=, \+, \{}等。前面所举的 .*的例子，由於 greedy的关系，在整篇文章中做替换时，会被当成是每一行整行，因为 regexp会去找每一行最长符合的那一个。 
    [实例 ]Thisisa test.Test forregexp.
    如果您下 :%s/[Tt].*t/program/g原意是想把所有的 Test或 test换成 program
    的，结果由於 regexp的贪心，整个 “This is a test. Test”会换成 program。结果原
    文就变成了 program for regexp.因此在全文替换时要非常小心，避免使用弹性太大
的 regexp。像此例，只要下 :%s/\<[Tt]est\>/program/g就可以了！

最后提醒您，这可不是 regexp的全部，碍於篇幅及在下功力的问题，当然是没办法全面详尽的向各位做介绍，在下只是将各位领进门，修行就得看各位了！如果还想更深入的研究 regexp，可参考： Mastering Regular Expressions(O’Reilly&Associates)一书。中文的话，可参考龙门少尉的网站： 
            http://www.rtfiber.com.tw/~changyj/
里头的『正规表示式入门与应用（一、二、三）』，非常值得研读。 

10.6 正则表达式实例

10.6.1 给网址加上<a>标签
/http:\/\/\f* 可以匹配一个普通的网址（不含 ? & 等符号的网址），
所以:s%/http:\/\/\f*/<a href="&">&<\/a>/g 可以把http://kikistar.com 替换成<a href="http://kikistar.com">http://kikistar.com</a> 。
如果网址中含有 ? & 等符号，例如http://www.newsmth.net/bbscon.php?bid=731&id=16603 ，把正则表达式稍微修改一下就行了：

:%s/http:\/\/\(?\|&\|\f\)*/<a href="&">&<\/a>/g

10.6.2 在所有html标记后换行
%s/<[^<>]*>/&\r/g

10.6.3 删除所有html标记
:%s/<[^<>]*>//g
:%s#<[^>]\+>##g

10.6.4 删除空行(无效)
:g/^\s*$/d

10.6.5 删除DOS换行符(^M这样的字符)
:%s/<C-V><C-M>//g          :  Ctrl-V是一种转义，它说要解释<C-M>，也可以在按<C-V>之后按回车。

10.6.6 在每一行前添加一行
:%s/.*$/\r&/g       

10.6.7 删除行尾空白
:%s= *$==

10.6.8 压缩空行,只保留一行空行
:%s/^\n\+/\r/

-----------------------------第10章结束-------------------------------

11 把 Vim折叠（ folding）？

把 Vim折叠（ folding）后，然后可以放入口袋？呵呵，当然不是这样啦！这是 Vim的一个很特殊功能（原始 vi及一般的 vi clone皆无此功能）。简单的说，就是可以将文章内容，依据他的结构，把多行内容集中於其中一个代表行来显示，萤幕上只看得到章节标题那一代表行，这样整个文章结构就一目了然，真正要阅读其他内容时，再由简单的按键或滑鼠来打开。这对於不含目录结构的文件或程式码很有用处。 

Vim中的折叠是可以嵌套的，即一个折叠可以包含几个折叠。折叠的层次可以通过set foldmethmax=n(n为1-20之内的任意整数，vim最多支持20层嵌套)来设置。

11.1 手动折叠(manual)

折叠的行为表现是由 foldmethod[fdm]这个设定项来控制的，手动折叠设置foldmethod为 manual或marker，就是手动设定，这是本节所要叙述的最基本折叠方式。其他折叠方式会在下一节介绍，折叠的方式，其中会有互相冲突的地方，使用上请注意一下。 

11.1.1 折叠的产生
手动产生折叠的指令是 zf、zF、:fo[ld]，以下以例子来说明较清楚。 
zfap          将游标所在处的那个段落折叠成一行。 
zf7G          自游标所在处至全文第 7行折叠起来。 
:3,9fold      将第 3行至第 7行折叠起来。 
:1,.fo        将第一行到当前行折叠起来。
5zF           将游标所在处起算 5行的内容折叠起来。也可以将所要折叠的部份以 Shift+v标记起来，然以按 zf就会将标记的内容折叠起来。 

11.1.2 折叠的操作 
zo 将游标所在处的折叠打开。 open。  
zc 将游标所在处已打开的内容再度折叠起来。 close。  
zr 将全文的所有折叠依层次通通打开。 reduce。  
zm 将全文已打开的折叠依层次通通再折叠起来。 more。  
zR 作用和 zr同，但会打开含巢状折叠（折叠中又还有折叠）的所有折叠。  
zM 作用和 zm同，但对於巢状折叠亦有作用。  
zi 这是个切换，是折叠与不折叠指令间的切换。  
zn 打开全文的所有折叠。 fold none。  
zN 这是 zn的相对指令，回复所有的折叠。 

那这个 zn和 zR不是都一样吗？不是的， zR的作用於 foldlevel这个设定项，是控制折叠的层次，而 zn则是作用於 foldenable这个设定项，他是不管层次的，只有全关或全开。当然，所得到的结果有许多情形下是一样的，但里子不一样，这在写 Vim script时得小心分辨。
通常，游标在折叠处向左或向右移的话，折叠也会自动打开。在进入编辑模式，例如按 i或 o，这是也会自动打开折叠。
其他的复制、删除及替换等动作还是可以和一般正常文稿一样的操作，例如 dd就会删掉一整个折叠， yy会复制一整个折叠， p会贴上一整个折叠。把整个折叠就当做是一行就行了。 

11.1.3 折叠的记忆

手动折叠，在下一次开档时就消失了，但我们可以使用 :mkview把折叠的情形记忆起来，下一次载入同一个档案时就可以下 :loadview，记忆起以前折叠的情况。当然，使用手动折叠及记忆，在操作上并不是很方便，除非是把他写成 Vim script来叫用。因此下一节要谈到自动折叠，这可能会比较实用一点。 

11.2 自动折叠

11.2.1 以缩行为依据 (indent)
:set foldmethod=indent就会依缩行来折叠（默认设置是 :set foldmethod=normal）。折叠的层级并不仅仅取决于你按了几个空格或制表符还与`shiftwidth‘有关。行的缩进宽度除以`shiftwidth‘，并向下取整得到每一行的折叠层级。同一折叠层级及更高折叠层级的连续行形成折叠。而其中的更高折叠层级的行——如果有的话，形成嵌套的折叠。
请注意，此时手动折叠的设定会被停止无法使用。 

11.2.2 以表达式 (expr) 
            :mkvimrc set foldmethod=expr，另外还要设定 :set foldexpr=...(一个正则表达式)，如设置每一行折叠：
:set foldmethod=expr
:set foldexpr=1

可参考线上使用手册 :h fold-expr的例子。 

11.2.3 以语法为依据 (syntax)
这是在定义语法（syntax）档时同时加入折叠的定义。然后， set foldmethod=syntax就会依照这个语法定义档去折叠，请 :h syn-fold。 

11.2.4 以是否更改过为依据 (diff)

做项目特别是多人项目的话总少不了做代码合并，这时候就需要比较一个文件不同版本的内容。VIM为程序员专门设计了用于代码比较的模式和功能，在命令行下，可以通过下列命令进入文件比较的模式：
sh$ vimdiff [file1] [file2]
sh$ vim -d [file1] [file2]

或者可以在VIM里直接用下列命令进入文件比较模式：
:vert diffsplit   <另一版本文件路径>

这在进入 vimdiff（即 vim -d file1 file2）时会自动进入 foldmethod=diff的模式，因此要 diff设定项设在同一个萤幕显示才行。以便整体的浏览。当然要自行更改预设值亦可。预设是： 
setlocal diff foldmethod=diff scrollbind nowrap foldlevel=1

这样一来，两个档案相同的部份会折叠起来，没有折叠的部份就是有差异的地方。 

有时候，您手上拿到的是别人给你的一个patch补丁文件。您可以在VIM里打开了原文件后，可以用下列命令根据补丁文件进入文件比较模式：
:vert diffpatch <补丁文件路径>      基于原文件和补丁文件查看

其实，文件比较模式的好处就是可以联动的翻页，也就是说，您在某个版本的窗口里翻页或滚动，另一个版本的窗口也会同时翻页或滚动。通过下面的配置项，可以实现这一点：
:set scrollbind    联动翻动（即一边翻动会同步的带动令一边）
在文件比较模式里，可以按 [c 跳到前一处发生修改的地方，按 ]c 跳到后一处修改的地方。
还有两个命令可以完成从一个窗口到另一个窗口的修改内容同步：
:diffput     将当前光标所在的一处更改复制到旁边的窗口（里面包含了另一个版本的文件）
:diffget     将当前光标所在的并在另一个窗口里的更改复制到当前窗口

有时候，您需要的是即时的修改某个文件，在修改过程中又需要清楚的知道自己这次修改了哪些地方，下面这个VIM函数脚本可以帮助到您：
function! DiffWithFileFromDisk()
    let filename=expand('%')
    let diffname = filename.'.fileFromBuffer'
    exec 'saveas! '.diffname
    diffthis
    vsplit
    exec 'edit '.filename
    diffthis
endfunction

11.2.5 以文件上的标志为依据 (marker)
这是跟据文章中的标志（marker）来做折叠。这些标志，起於 {{{，止於 }}}，这中间的部份会折叠起来。通常这些标志是藏在注解栏里头，例如 C程式码的 /*及 */之间， shell script的 #之后， Vim script的 "之后，得视程式语言的不同而定，因此一般的文章就不适合使用了。 这些预设的标志也可以由 foldmarker来更改，但为了文件的流通性，建议使用预设值就可以了。 当然，一些程式码载入时再来设定 :set foldmethod=marker就太麻烦了，这个设定可以设在文件内，例如： 
#!/bin/sh 
#这是一个 sh script 
# {{{ 
...
这里是 script内容，由 vim打开这
个档时，这个部份会自动折叠起来。 
... 
# }}} 
# vim:fdm=marker:ts=2

还记得 modeline吗？请复习一下第 9章。 

-----------------------------第11章结束-------------------------------

12 Vim tags的使用 

tag指的是文件中的一种特殊的标志，在使用 Vim时，可以由很简单的按键就马上跳到那个文章及那个 tag的位置，也可以跳回原处。这个功能就好像目前的网页上的 hyperlink一样。但不一样的是，这个 tag并不是写在文件里头的，而是由 ctags这支程式（或其他类此的工具程式）来产生相关档的 tags，然后存档於一个外部档案里头，要用到时再由 Vim叫出来。 
12.1 各种程式码专用 tag工具 
ctags 这是最常用到的，可能会有两种版本，旧的 ctags只能用於 C程式 
码。 exuberant ctags则可用於 C/C++、Java、Fortran· · · · · ·等等。可由  
ctags -version得知版本。  
etags 这是 emacs/xemacs所附的，功能也是非常强大。  
JTags 这只能处理 Java程式码。  
    ptags.py 处理 Python程式码。  
ptags 处理 Perl程式码。 

这里主要讲述 exuberant ctags。可 man ctags或 ctags -help得知所支援的程式语言。在 $VIMRUNTIME/tools目录下会有一些工具可以使用，例如专用在 sh script，Tcl/Tk script的 tag工具。其他的 tags工具，系统上不一会安装，有需要的话得自行安装，一般使用，应该 ctags就够用了， ctags也可以模拟 etags。
    以往， Vim会附上 exuberant ctags，但新近的版本已没有附上，得由使用者自行安装，或使用系统上就有的 ctags。如果系统上的并不是 exuberant ctags，可自行由 http://ctags. 
    sourceforge.net下载、安装。 

12.2 tags档案的格式
以下是一般 tag档的结构（以一行为例）： 
tagname TAB tagfile TAB tagaddress term field 
tagname 这是识别字的名称，通常就是一些函数名，或其他任何识别字。  
TAB 这是老老实实的一个 Tab键。  
    tag.le 这是 tag档的档名。  
tagaddress 这是 Ex指令，通常就是搜寻指令，但行数也是可以。  
term  ;"这个记号（两个字元）以后的内容视为注解。  
.eld 待了解。  

12.3 tag档案的制作
不讲究的话，可以在所解开的 source code目录下，下以下指令： 
ctags -R *
这样会有 source code目录下产生一个 tags这个档（可以使用 -f选项来指定档案名），里头就包含了整个 source code的所有档案的 tags资讯，包括其下所有的子目录下的档案。 ctags已尽可能的做到聪明扫描档案的能力，会忽略和程式码无关的档案。当然 ctags还有许多精细的参数可以使用，请 man ctags。
请注意， ctags预设会将输出档排序，因此不必自行另外去排序。有排序有一个好处，那就是 Vim会去使用 binary search的方式去搜寻，这样会比较快。 
12.4 一般的 tag使用
        如果就照上一节的方式产生 tag .les，那么只要在 source code目录下由 vim去开启档案的话，会自动载入 tags这个档案，无需另行载入，否则要由 :set tags=your.tags来指定 tags档。然后就是照一般使用 Vim线上说明一样，游标移到识别字或函数名上，按 Ctrl+]，要回到原处就按 Ctrl+T。 

    请注意， Vim启动时，工作目录（ vim启动时的所在目录）名为 tags的档案会自动载入， $VIMRUNTIME/doc及 $HOME/.vim/doc目录下的 tags档也会自动载入。而且，凡是载入的 tags档里头所有标志文字都可以使用补全键来补全，别忘了这个好用的功能。 

12.5 Vim线上说明文件的制作 
Vim的线上说明文件就是使用 tags的方式来管理的，因此使用方法也是和一般 tags档一样，由 Ctrl+]及 Ctrl+T来控制。 

12.5.1 doctags
这个工具一般不会在系统的 $PATH里头，而是在 Vim原始码的 runtime/doc目录下。由於一般 tags程式只对程式码作用，因此对一般的文字档没有作用。而这个 doctags则会依文字档中有 *这是标题 *标志的内容做出 tag档出来。
在 source code，进入 runtime/doc目录后： 
make doctags =>编译出 doctags这个可执行档 
    make tags =>制作此目录下所有 *.txt的 tags档
    这个 doctags也可以保留下来，把自己新制作的 *.txt置於 $VIMRUNTIME/doc目录下，执行： 
    doctags *.txt | sort > tags
这样就行了，重新进入 vim后就可以使用了。
当然，这个工具需自行编译，因此对一般使用者而言，使用上并不方便。其实 Vim已有内建这个工具了。 

12.5.2 由 Vim里头作线上说明
    进入 vim后， :helpt[ags]目录名这样就会把所指定目录下的所有 *.txt产生 tags档案。这个动作也可以由命令列来执行： 
    vim -c "helptags ." -c quit 
        第 12章 Vim tags的使用 12.5. VIM线上说明文件的制作
这和 
    doctags *.txt | sort > tags
是一样的。
        由於 Vim自动会搜寻的文件目录是，目前工作目录、 $VIMRUNTIME/doc及 $HOME/.vim/doc因此建议把自己的新文件置於 $HOME/.vim/doc较好。以下为一个简单的例子： 
    This is a test. *test1* 
    This is another test. *test2*
        存档成 test.txt置於 $HOME/.vim/doc目录下： 
    cd .vim/doc 
    vim -c "helptags ." -c quit
重新开启 vim，然后 :h test1试看看就知道怎么一回事了。而按 F1求助键的话，会发现在后面的炮份多了一个章节，那就是 LOCAL ADDITIONS:，家目录下的文件目录就是置放於此。 

-----------------------------第12章结束-------------------------------

13 Vim script简介

原始的 vi本就有一些简单的 macro语法，可以设定一些复杂的编辑动作於一个指令，等於是在创造一个新的指令。 Vim则更进一步把他发展成程式语言。在 Vim中，一般的设定档，如 vimrc及一些 syntax/plugin档，都是由 Vim script写成的。可以设定变数，也有回圈、条件判断及内建函数可以使用，更可以自订函数，俨然就是一个程式语言雏形了。当然，原始的 vi macro语法还是认得的，这点不必担心。

由於 Vim script的大大扩充，虽然说是简介，但内容可能会比其他的章节多，而且可能会比较深入一些，可以视情形，捡几个顺手的例子来用，不必一开始就要通通搞懂他。 :-) 

13.1 一些简单的macro

这里指的 macro是一般的键盘对应、缩写设定及简单的新命令定义，虽然也是会使用到 Vim script，但由於并不是完整的规划、设计，因此就以 macro为名来代表（当然，实质上也是利用 Vim script来书写的）。 

13.1.1 按键对应 
    Vim可以将多个动作（命令或是函数）对应给一个简单的按键，这样一来就可以很方便的按个键去执行所定义的动作，基本的例子就是第 9.7节，页 38的一些实际例子。由於 Vim预设已经内建把 F1键定义给线上求助档，因此，这个键就不要去麻烦他了。
一些按键的书写方法
在传统的按键对应，有他的简单书写方法，但通常并不是很直觉， Vim则改进了书写方法，可以很直觉的书写。以下是一些例子： 
<Esc> Esc键。 
<Tab> Tab键。 
<Home> Home键。 
<Del> Del键。 
<CR> Enter键。 
<Enter> Enter键，和上面的相同。 
<LT>就是 <，在和 <字元本身会有混淆、疑义时使用。也可以使用 \<。 
<BS> Backspace倒退键。 
<Up> PageUp向上翻页键。 
<F5> F5功能键。 
<C-G> Ctrl+G键。

要注意的是，大小写是不分的，以上的书写只是为了阅读方便而已。详细的按键符号，这里就不多说明了，有需要的话，可以进入 vim后 :h key-notation，就会有详细的列表。 

\<的使用只能在 cpoptions设定项不含 B旗标时才能使用，通常 B旗标预设是会有的，请 :set cpoptiions?就可知道目前的设定。

要非常小心的是，这种直觉的书写方式，不能用於 :set及 :autocmd的情形，因为角括号在里头有其他的特殊意义。通常，这只能用於按键的对应，缩写及选单设定的情况。 

map指令的种类 

Vim除了原始的 map[!]外，扩充了相当多的类似 map指令。各在不同的模式作用。 map主要是作用於常态模式及反白模式，而 map!则是作用於插入模式及命令列模式。 vmap仅在反白模式时作用， Visual mode。 nmap仅在常态模式时作用， Normal mode。 imap仅在插入模式时作用， Insert mode。 omap仅在操作等待模式时作用， Operator-pending mode。 cmap仅在命令列模式时作用， Command-line mode。 

[实例 ]:map <F5> bi{<Esc>ea}<Esc>这样一来，只要在英文单字任意处按 F5，这个英文单字的前后就会加上大括号。说明如下： 
bi{<Esc>按 b移至英文单字的第一个字母处，并按 i进入插入模式，写入 {这个字元，
并按 Esc键，回复常态模式。 
e移动至这个英文单字的最后一个字母处。 
a}<Esc>进入插入 append模式，并输入 }这个字元，再回到常态模式。

需注意的是，在命令列模式前头会有个冒号，因为在 vim里头，要按个冒号才会进入命令列模式。但如果是设在 Vim script档里头当然就没有冒号了。以上的例子也是可以对应至一些较容易记忆的按键，例如： 
map ,b bi{<Esc>ea}<Esc>
这样按 “,b”就会有同样的作用，但 “,”及 “b”之间不能相隔太久的时间，这样 Vim才会知道这两个按键是结合在一起的 1。而 b在此就代表 braces（大括号）。

如果要知道目前的按键对应的情形，可:map就会列出所有的目前按键对应，前面标示的记踸就是各种模式的代表字母，例如 n代表 normal，i代表 insert。 

防止重复对应

为了防止重复对应到已有定义的按键，通常指令内可加入 nore的字样，例如： 
:noremap => Normal, Visual and Operator-pending 
:vnoremap => Visual 
:nnoremap => Normal 
:onoremap => Operator-pending 
:noremap! => Insert and Command-line 
:inoremap => Insert 
:cnoremap => Command-line
其实其他对应性质的指令也是会有类似的这种指令，请参考下一节。 

13.1.2 缩写对应

缩写对应是把一长串的字串对应到简单的几个代表性字串。缩写的对应只能用在插入模式、取代模式及命令列模式。主要用於输入时节省时间及避免拼错。这里利用例子来做说明： 
1可以在底下的状态列看得到按键，按 “,”会显示出来，等一段时间后又会消失，在这段时间内按 “b”，那 Vim就会把他当做两个键是结合在一起的。 

[实例 ]:ab gl GNU Linux
        把 gl这个按键对应成 GNU Linux。 ab是 abbreviate的缩写，这样一来，在插入模式时，只要输入 gl，再按 Sapce键或 Ctril+]，这个 gl就会变成 GNU Linux这个字串。 Sapce和 Ctril+]的区别在於前者会多留个空白，方便继续输入其他文字；而后者则不会多留个空白。要注意的是，这在取代模式（请参考第 3.1.2节，页 10）、命令列模式（请参考第1.4节，页4）也是可以作用，如果是使用 
:ia[bbrev]，那只会在插入模式及取代模式有作用。
以下是一些常会用到的指令： 
:ab[breviate] 不接任何参数，这会列出目前所有的缩写对应。其中标有 ‘i’的，代 
表作用於插入模式；标有 ‘c’的，代表作用於命令列模式；标有 ‘!’ 
的，则两种模式皆有作用。  
:ab gl 这会列出 gl是对应成什么字串。  
:una[bbreviate] gl 取消 gl这个对应。  
:ia[bbrev] 和 :ab的定义一样，但只作用於插入模式。  
:cb[bbrev] 和 :ab的定义一样，但只作用於命令列模式。  
:norea[bbrev] 用於防止重对应已有对应的字串。  
:abc[lear] 取消所有由 :ab所定义的对应。  
:iabc[lear] 取消所有由 :ia所定义的对应。  
:cabc[lear] 取消所有由 :ca所定义的对应。  

13.1.3 定义新命令 

Vim提供自行定义新命令的方法，其语法是： 
:com[mand][!] [属性 ······]新命令名动作
属性的部份较复杂，在此先省略不谈，底下再来详细说明。其中 ‘!’代表强制定义已有的命令，否则已存在的命令是不允许重定义的。新命令名也是有限制： 
(1)
必需以大写英文字母开头。 

(2)不能使用 
:X，:Next，:Print，这三个保留字。 

(3)
其他的部份，可以是字母或数字，分大小写，但不能使用底线。但不建议使用数目字。


通常此类新命令的定义是使用在 Vim script的场合。 

13.1.4 新命令的属性 

Vim会把这些命令当成是 ex命令一般的地位。这里的所谓属性指的是新命令所能使用的参数及是否可以指定范围等等。这里分成四个部份来说明：参数、补全动作、范围指定及特殊情形。
参数
新命令可以使用 -nargs属性来指定参数的性质。 
-nargs=0这是预设，就是没有参数，可以省略不写。 
-nargs=1需要一个参数。 
-nargs=*是否有参数及参数数目不拘。 
-nargs=?允许零或一个参数。 
-nargs=+必须有参数，但参数数目不拘。

参数之间以空白或 Tab区隔。实际上定义时，置放参数的位置是以 <args>来代表的。 
<args>一般使用，但参数内无法使用双引号。 
<q-args>和 <args>同，但可以使用双引号。 
<f-args>用於函数内所要用到的参数。 

13.2 Vim script的语法 

Vim script只有两种资料型态，数字及字串。 

-----------------------------第13章结束-------------------------------

14 vim 的插件

vim 有一套自己的脚本语言,通过这种脚本语言可以实现与 vim 交互的,达到功能扩展的目的。一组 vim 脚本就是一个 vim 插件,vim 的很多功能都是通过其插件实现,在官网上有丰富的插件资源,任何你想得到的功能,如果 vim 无法直接支持,那一般都有对应的插件为你服务,有需求时可以去逛逛。

vim 插件目前分为两类:*.vim 和*.vba。前者是传统格式的插件,实际上就是一个文本文件,通常 someplugin.vim (插件脚本)与 someplugin.txt(插件帮助文件)并存在一个打包文件中,解包后将 someplugin.vim 拷贝到~/.vim/plugin/目录,someplugin.txt 拷贝到~/.vim/doc/目录即可完成安装,重启 vim 后刚安装的插件就已经生效,但帮助文件需执行 helptags ~/.vim/doc/才能生效。传统格式插件需要解包和两次拷贝才能完成安装,相对较繁琐,所以后来又出现了*.vba 格式插件,安装更便捷,只需在shell 中依次执行如下命令即可:
       vim someplugin.vba
       :so %
       :q

为使用vim更好地使用插件，最好在.vimrc中进行一些基本的设置
    set nocompatible
    filetype plugin on
    syntax on

14.1 mru.vim

14.2 vim-autocomplpop.zip

14.3 snipMate.zip tab键代码段补全 
可通过:h snipMate查看帮助
按C+tab可以查看可用的触发器
来源：http://www.douban.com/group/topic/9466287/
在你的~/.vim/snippets/目录中有各种文件片段定义文档，他会根据你编辑的文档类型选择不同的片段文档，比如你正在编辑一个 html文档，它就会 首先 扫描~/.vim/snippets/目录中的html.snippets文件中所定义的所有片段定义 ，如果没找到则继续在 ~/.vim/snippets/目录中的 _.snippets 文件中所搜，此文件可定义针对任意文件类型都适用的自定义代码片段，当然其他针对各文件类型的片段定义也可以任意修改。

片段定义规则有以下几个就比较常用的规则：
* 片段基本格式：
snippet [trigger]
[snippets,,,,]
[snippets,,,,]

* ${n} 代表第几个停靠点,注意的是停靠点可以不按先后顺序定义，也就是你可定义类似下面的片段定义：
snippet test
some code ${3} some code ${1} some code ${2}
按<tab>键它会按数字顺序跳动

* 可以设置更新一个停靠点内容时可以同时一个或多个其它规定非停靠点的内容，
如可以作如下定义 ，
snippet test
some code ${1:}
some code $1
some $1 code
当你更新${1:}停靠点处内容时，其它$1标志处内容同步进行更新。
需要注意的是${1:}中的冒号后可以添加任意提示代码 ，但在此不可以省略，否则，$1不会被更新。

* 其它内容规则可以在 ~/.vim/doc/snipMate.txt中查看，内容并不是很多。

14.3.2 几个文件目录的说明：
顶层目录：
~/.vim/bundle/snipMate/
    +after/plugin/snipMate.vim     "在这个文件里面可以修改触发键，默认为
    +autoload/snipMate.vim         "
    +plugin/snipMate.vim            "功能实现文件
    +snippets/*                         "不同语言的预定义片段，以snippets/filetype/*.snippet或snippets/filetype.snippet

snipMate按照指示安装成功后，通常就可以正常工作了。我安装后，HTML类型的文件无法自动触发，于是在.vimrc内添加以下内容： 
    autocmd FileType html set ft=html.markdown 

如果这样还不行，那就只好在编辑HTML文件时，手动设置：set ft=html.markdow。在插入模式下，按C+tab可以查看可用的触发器，个人觉得非常有用。

14.3.3 修改snipMate的快捷键
在.vimrc中插入以下内容，把快捷键改成<c-j>。
ino <c-j> <c-r>=TriggerSnippet()<cr>
snor <c-j> <esc>i<right><c-r>=TriggerSnippet()<cr>
* 我还是不太明白这两行的作用，好像这样设置之后，<tab>还是有效。所以不推荐这样设置，还是修改$VIMFILES/af  /plugin/snipMate.vim好。

14.3.4 acp-snipMate的修改
添加如下代码到$VIMFILES/plugin/snipMate.vim：
  fun! GetSnipsInCurrentScope()
    let snips = {}
    for scope in [bufnr('%')] + split(&ft, '\.') + ['_']
      call extend(snips, get(s:snippets, scope, {}), 'keep')
      call extend(snips, get(s:multi_snips, scope, {}), 'keep')
    endfor
    return snips
  endf

在.vimrc中添加：
let g:acp_behaviorSnipmateLength=1


14.4 CSS.vim CSS颜色预览插件,文件后辍名要为.css

14.5 cs Explorer 快速切换配色方案

14.6 NERD tree

14.7 calendar.vim

14.8 ctags5.8 

14.9 taglist.vim 提供单个源代码文件的函数列表
taglist配置选项，你可以根据自己的习惯进行配置： 

Tlist_Ctags_Cmd选项用于指定你的Exuberant ctags程序的位置，如果它没在你PATH变量所定义的路径中，需要使用此选项设置一下； 
如果你不想同时显示多个文件中的tag，设置Tlist_Show_One_File为1。缺省为显示多个文件中的tag； 
设置Tlist_Sort_Type为”name“可以使taglist以tag名字进行排序，缺省是按tag在文件中出现的顺序进行排序。按tag出现的范围（即所属的namespace或class）排序，已经加入taglist的TODO List，但尚未支持； 
如果你在想taglist窗口是最后一个窗口时退出vim，设置Tlist_Exit_OnlyWindow为1； 
如果你想taglist窗口出现在右侧，设置Tlist_Use_Right_Window为1。缺省显示在左侧。 
在gvim中，如果你想显示taglist菜单，设置Tlist_Show_Menu为1。你可以使用Tlist_Max_Submenu_Items和Tlist_Max_Tag_Length来控制菜单条目数和所显示tag名字的长度； 
缺省情况下，在双击一个tag时，才会跳到该tag定义的位置，如果你想单击tag就跳转，设置Tlist_Use_SingleClick为1； 
如果你想在启动vim后，自动打开taglist窗口，设置Tlist_Auto_Open为1； 
如果你希望在选择了tag后自动关闭taglist窗口，设置Tlist_Close_On_Select为1； 
当同时显示多个文件中的tag时，设置Tlist_File_Fold_Auto_Close为1，可使taglist只显示当前文件tag，其它文件的tag都被折叠起来。 
在使用:TlistToggle打开taglist窗口时，如果希望输入焦点在taglist窗口中，设置Tlist_GainFocus_On_ToggleOpen为1； 
如果希望taglist始终解析文件中的tag，不管taglist窗口有没有打开，设置Tlist_Process_File_Always为1； 
Tlist_WinHeight和Tlist_WinWidth可以设置taglist窗口的高度和宽度。Tlist_Use_Horiz_Window为1设置taglist窗口横向显示； 
在taglist窗口中，可以使用下面的快捷键： 
<CR>          跳到光标下tag所定义的位置，用鼠标双击此tag功能也一样
o             在一个新打开的窗口中显示光标下tag
<Space>       显示光标下tag的原型定义
u             更新taglist窗口中的tag
s             更改排序方式，在按名字排序和按出现顺序排序间切换
x             taglist窗口放大和缩小，方便查看较长的tag
+             打开一个折叠，同zo
-             将tag折叠起来，同zc
*             打开所有的折叠，同zR
=             将所有tag折叠起来，同zM
[[            跳到前一个文件
]]            跳到后一个文件
q             关闭taglist窗口
<F1>          显示帮助 可以用”:TlistOpen“打开taglist窗口，用”:TlistClose“关闭taglist窗口。或者使用”:TlistToggle“在打开和关闭间切换。在我的vimrc中定义了下面的映射，使用<F9>键就可以打开/关闭taglist窗口： 
map <silent> <F9> :TlistToggle<cr> Taglist插件还提供了很多命令，你甚至可以用这些命令创建一个taglist的会话，然后在下次进入vim时加载此会话。 

不显示方框的方法：
在“call append(0, '" Press <F1> to display help text')”这一行下添加下面一行：
exe ':set foldcolumn=0'

 选项控制变量

在Vim配置文件中，可通过"let"语句设定以下变量控制taglist：

    * Tlist_GainFocus_On_ToggleOpen : 为1则使用TlistToggle打开标签列表窗口后会获焦点至于标签列表窗口；为0则taglist打开后焦点仍保持在代码窗口
    * Tlist_Auto_Open : 为1则Vim启动后自动打开标签列表窗口
    * Tlist_Close_On_Select : 选择标签或文件后是否自动关闭标签列表窗口
    * Tlist_Exit_OnlyWindow : Vim当前仅打开标签列表窗口时，是否自动退出Vim
    * Tlist_Use_SingleClick : 是否将默认双击标答打开定义的方式更改为单击后打开标签
    * Tlist_Auto_Highlight_Tag : 是否高亮显示当前标签。命令":TlistHighlightTag"也可达到同样效果
    * Tlist_Highlight_Tag_On_BufEnter : 默认情况下，Vim打开/切换至一个新的缓冲区/文件后，标签列表窗口会自动将当前代码窗口对应的标签高亮显示。TlistHighlight_Tag_On_BufEnter置为0可禁止以上行为
    * Tlist_Process_File_Always : 为1则即使标签列表窗口未打开，taglist仍然会在后台处理vim所打开文件的标签
    * Tlist_Auto_Update : 打开/禁止taglist在打开新文件或修改文件后自动更新标签。禁止自动更新后，taglist仅在使用:TlistUpdate,:TlistAddFiles，或:TlistAddFilesRecursive命令后更新标签
    * Tlist_File_Fold_Auto_Close : 自动关闭标签列表窗口中非激活文件/缓冲区所在文档标签树，仅显示当前缓冲区标签树
    * Tlist_Sort_Type : 标签排序依据，可以为"name"（按标签名排序）或"order"（按标签在文件中出现的顺序，默认值）
    * Tlist_Use_Horiz_Window : 标签列表窗口使用水平分割样式
    * Tlist_Use_Right_Window : 标签列表窗口显示在右侧（使用垂直分割样式时）
    * Tlist_WinWidth : 设定水平分割时标签列表窗口的宽度
    * Tlist_WinHeight : 设定垂直分割时标签列表窗口的高度
    * Tlist_Inc_Winwidth : 显示标签列表窗口时允许/禁止扩展Vim窗口宽度
    * Tlist_Compact_Format : 减少标签列表窗口中的空白行
    * Tlist_Enable_Fold_Column : 是否不显示Vim目录列
    * Tlist_Display_Prototype : 是否在标签列表窗口用标签原型替代标签名
    * Tlist_Display_Tag_Scope : 在标签名后是否显示标签有效范围
    * Tlist_Show_Menu : 在图型界面Vim中，是否以下拉菜单方式显示当前文件中的标签
    * Tlist_Max_Submenu_Item : 子菜单项上限值。如子菜单项超出此上限将会被分隔到多个子菜单中。缺省值为25
    * Tlist_Max_Tag_Length : 标签菜单中标签长度上限

taglist命令

taglist在Vim中提供了以下扩展命令:

    * :TlistAddFiles {files(s)} [file(s)...] 添加一或多个指定文件(的标签项)到标签列表窗口中。文件名表达式中可使用通配符(*);如文件名中带有空格，需要使用反斜杠对空格进行转义("\ ")
    * :TlistAddFilesRecursive {directory} [{pattern}] 遍历指定路径{directory}，将与模式{pattern}相匹配的文件加入标签列表窗口。如未指定pattern，则使用缺省值'*'。如路径中包含空格，需使用反斜杠'\'转义("\ ")
    * :TlistClose 关闭标签列表窗口
    * :TlistDebug [filename] 记录taglist插件的调试信息。如指定了filename，则调试信息将被写入此指定文件（如文件已存在，内容将被覆盖)；如未指定filename，则调试信息写入脚本的局部变量中
    * :TlistLock 锁定标签列表，并且不处理新打开的文件
    * :TlistMessage 仅当调试信息写入脚本局部变量时有效，显示记录的调试信息
    * :TlistOpen 打开并跳转至标签列表窗口
    * :TlistSessionSave {filename} 将当前打开文件及其标签信息写入指定文件
    * :TlistSessionLoad {filename} 从指定文件载入所保存的会话信息
    * :TlistShowPrototype [filename] [linenumber] 显示指定文件中指定代码行或之前的标签的原型。如未指定文件名/行号，则使用当前文件名/当前行号
    * :TlistShowTag [filename] [linenumber] 显示指定文件中指定代码行或之前标签名称。如未指定文件名/行号，则使用当前文件名/当前行号
    * :TlistHighlightTag 加亮显示标签窗口中的当前标签
    * :TlistToggle 在打开和关闭状态间切换标签窗口的状态。标签窗口切换至打开状态后仍然光标保持在代码窗口中
    * :TlistUndebug 停止记录taglist插件调试信息
    * :TlistUnlock 解锁标签列表，并处理新打开的文件
    * :TlistUpdate 更新当前缓冲区的标签信息

全局函数

taglist插件为Vim提供了一些全局函数，可供其他插件使用:

    * Tlist_Update_File_Tags({filename}, {filetype}) 以指定文件类型更新指定文件的标签信息。如taglist插件此前未处理过指定文件，则会调用ctags对文件进行分析
    * Tlist_Get_Tag_Prototype_By_Line([{filename}, {linenumber}]) 获取指定文件中指定行号或之前标签的原型信息。如未指定文件名/行号，则使用当前缓冲区对应文件/当前行号
    * Tlist_Get_Tagname_By_Line ([{filename}, {linenumber}]) 获取指定文件中指定行号或之前标签的名称信息。如未指定文件名/行号，则使用当前缓冲区对应文件/当前行号
    * Tlist_Set_App({appname}) 设置正在控制taglist的插件名称



14.10 python_pydiction.vim  版本1.2

14.10.1 插件简介及安装
功能：提供python的代码提示功能
问题：默认唤醒键是<Tab>与snipMate有冲突(相同)
下载：http://www.vim.org/scripts/script.php?script_id=850
安装：
①安装python_pydiction.vim
对于Windows系统：把python_pydiction.vim存放到$vimfiles\ftplugin
对于UNIX/LINUX系统：把python_pydiction.vim存放到$vimfiles/after/ftplugin/。如果无法的话在$vimfiles/plugin也存放一份
②安装字典
把字典文件complete-dict复印到$vimfiles/dict目录下，改名为pydiction.dict，在.vimrc中添加下面一行
let g:pydiction_location = $VIMFILES.'/dict/pydiction.dict'
③pydiction.py的使用
pydiction.py文件是用来生成数据字典的，新加一个python库，生成一下，具体教程可以看官方的说明。

14.10.2 修改快捷键,解决与snipMate的冲突
snipMate与pydiction都是使用Tab键补全，会存在冲突。通过修改其中一个的快捷键可以解决这个冲突。我选择修改pydiction的快捷键，修改方法如下：
打开python_pydiction.vim文件，找到这行
inoremap <silent> <buffer> <TAB>
修改为下面这样，就可以通过Ctrl+n来进行补全了。
inoremap <silent> <buffer> <C-l>

14.11 tetrls.vim 俄罗斯方块

14.12 nibble 贪吃蛇 游戏插件

14.13 genutils 解决一些函数支持

14.14 html.vim、 htmlcomplete.vim和html5.vim html5自动补全

14.15 css.vim、csscomplete.vim css自动补全

14.16 asx.snippets asx的smipMate的模板语法文件 

14.17 txtbrowser-1.3.4 txt浏览

14.18 zencoding.vim

14.19 syntax/2html.vim 把当前文档转化成html文档 Vim自带

14.20 winManager 文件浏览器和窗口管理器 

14.21 statusline.vim

14.22 vimim.vim,vimim.pin_huge.txt,vimim.wubijd.txt

14.23 Template.vim

14.24 fcitx.vim

14.25 vimwiki 
参考文章：[投稿]Pkm工具：Vimwiki

14.25.1 Vimwiki键盘指令
<Leader>ww -- 打开默认的wiki主页
<Leader>wt -- 在新的标签页中打开默认的wiki主页
<Leader>ws -- Select and open wiki index file.(未知)
<Leader>wd -- 删除你所在的wikiword的页面
<Leader>wr -- 重命名你所在的wikiword页面
Backspace -- 返回上一页
Tab -- 寻找下一个wikiword
Shift Tab -- 寻找上一个wikiword
如果有什么不懂,可输入在"Normal"下输入":h vimwiki-mappings"查询

14.25.2 创建新页面
使用[[]]把要创建的文件名框起来，在方括号内按回车。如果要创建的文件名是驼峰词，则可不用用方括号。

14.25.3 跳转到新建的页面
在Normal模式下按Tab移动到要跳转的页面的名字
- Enter：与双击效果等同，在当前窗口中打开NewPage页面。
- Shift+Enter：上下分割窗口，NewPage在上，原页面在下。
- Ctrl+Enter：左右分割窗口，NewPage在左，原页面在右。

14.25.3 Vimwiki发布为html网页
Vimwiki可导出为html格式，便于发布为网页。
输入':Vimwiki2HTML -- 将当前wiki页转换成Html格式'
输入':VimwikiAll2HLML -- 将所有的wiki页转换成HTML格式'

14.26 quickfix 

14.27 git-vim
下面简单记一下它的使用方法：

安装（传统方式）


$ git clone git://github.com/motemen/git-vim.git
$ cd git-vim
$ cp -r plugin syntax ~/.vim/

安装（vim-addon-manager方式）

把下面这几句加到vimrc里面

let addon_list = []

let addon_list += [ "git-vim"]

call vam#ActivateAddons(addon_list)



" 设置git-vim的源代码地址  {{{ 
let g:vim_addon_manager['plugin_sources']['git-vim'] = 
            \{"type":"git", "url":"git://github.com/motemen/git-vim.git"}
" }}}


在状态栏上显示branch信息

修改.vimrc文件，添加一下代码

set laststatus=2
set statusline=%{GitBranch()}
这里其实就是使用git.vim内置的GitBranch()函数来显示信息，其实也可以在原有statusline上加入此函数，下面是我所是用的statusline

set statusline=”%F%m%r%h%w\ [%{&ff}]\ [%Y]\ [%{(&fenc==\"\")?&enc:&fenc}%{(&bomb?\",BOM\":\"\")}]\ [ASCII=\%03.3b]\ [HEX=\%02.2B]\ [POS=%04l,%04v][%p%%]\ [LEN=%L]\ %=[%{GitBranch()}]“

常用命令 

:GitAdd
:GitCommit
:GitStatus
:GitLog
:GitCheckout
:GitDiff
:GitPull
:GitPush
快捷键

<Leader>gd 等同于 :GitDiff
<Leader>gD 等同于 :GitDiff —cached
<Leader>gs 等同于 :GitStatus
<Leader>gl 等同于 :GitLog
<Leader>ga 等同于 :GitAdd
<Leader>gA 等同于 :GitAdd <cfile>
<Leader>gc 等同于 :GitCommit

默认情况下等于”,”

-----------------------------第14章结束-------------------------------

15 Vim和其他软体的配合

编辑器毕竟是有其特定功能，无法包山包海的把一些电脑上会用到的功能通通整合进去。但由於 Vim提供了 Vim script及和外部 shell沟通的功能，因此很容易就可以把 Vim和其他软体结合起来使用，不必在编辑文件时还要退出 Vim去执行其他应用软体。 

15.1 和邮件新闻软体的配合
这里只以个人使用的 mutt/slrn为例，其他的类似软体就请各位发挥想像力罗！ 

15.1.1 mutt + vim 
    # ~/.muttrc 
set editor="vi -c ’:0;/^$’" 

15.1.2 slrn + vim 
    # ~/.slrnrc 
set editor_command "vi -c ’:0;/^$’ ’%s’"
     这个 -c参数的意思，就是进入 Vim后，马上执行参数后的 Vim ex命令。在此是 :0;/.$，什么意思？该去复习一下正则表达式罗！这会移至信件表头与信件实际内容的中间（就是全文中第一个遇到的空白行），以便可以方便马上就地编辑。首先 :0是移到文件的第一行，然后 /.$是找第一个空白行。 

15.2 和编译程式的配合

15.3 和TEX/LATEX的配合 

15.4 和Java的配合 

这和一般使用者的关系不大，但对於写程式的人来说就非常方便了。 

15.5 和git的配合


-----------------------------第15章结束-------------------------------

16 Vim tips集锦

本章是一些实际上常用、好用的 tips集锦。当然每个人的使用习惯并不一样，因此这些 tips不可能适合每一个人，但可以经由修改，改成自己满意的使用方法，这才是本章的重点所在。 

16.1 分栏显示文本
有20行文本长短不一，现要把11-20行整体搬移到1-10后的后面，行与行对应。1-10行最长有20字符，11-20行就从30字符处开始。
方法一：
:1,20!pr -2t
方法二：
:1,10g/^/s/.*/\=printf("%-30s",submatch(0))/|+10t,|-1j
:11,20d
来源：http://blah.blogsome.com/2007/10/13/p51/

16.2 以指定编码打开、编辑文件
打开：vim File_name -c "e ++enc=gb18030"
编辑：:e ++enc=gb18030

16.3 和段落标记（^M）有关的操作

16.3.1 显示所有的^M符号
:e ++ff=unix %

16.3.2 删除所有的^M符号
:e ++ff=unix %
:%s/<C-V><C-M>//g
Ctrl-V是一种转义，它的意思是“解释<C-M>”，也可以在按<C-V>之后回车。
只有先把段落标记^M显示出来，才能把它删除。

16.4 在插入模式下临时执行命令
Ctrl+o

16.5 删除行尾空白
:%s= *$==

16.6 压缩空行——只保留一行空行
:%s/^\n\+/\r/

16.7 在文本中插入行号
来源：http://blah.blogsome.com/2007/06/27/vim_line_no/
方法一：使用line函数
" 为所有行加上行号
" 使用合适的范围或者正则表达式就可以限定作用的范围。
:g/^/ s//\=line('.').' '/
方法二：使用EX命令
" 为前30行加上行号
:redir @a | 1,30# | redir END
:1,30d | put! a
方法三：使用RANGE()函数
" 为前30行加上行号
:for i in range(31)
:call setline(i,i .' '. getline(i))
:endfor
方法四：加法运算
" 为所有行加上行号
:let i=1
:g/^/ s//\=i . ' '/ |let i=i+1
方法四：使用cat命令
:%!cat -n
还有很多种方法，详见上面的网址。

16.8 匹非ASCII码的集合（包括汉字）
:/[^\x00-\x7f]\+

16.9 让你更了解vim 

16.9.1 显示所有命令
:map
16.9.2 查看所有预定命令
:h index
16.9.3 如何相看vim内部函数
Vim 内部定义了一百多个函数，详细列表请参见“:help function-list”。

16.10 判断操作系统
if has("win32")
    是windows32位系统
else
    非windows32位系统
endif
要判断更多内容可以查看“:h feature-list”。

16.11 建立自己的菜单项
amenu Modeline.Insert\ a\ VIM\ modeline <Esc><Esc>ggOvim:ff=unix ts=4 ss=4<CR>vim60:fdm=marker<esc>gg

16.12 统计一个词出现次数
:%s/word//gn
(详细：h count-items)

16.13 加强VIM对函数做及HTML等标记语言的处理
来源：http://www.vimer.cn/2009/10/%E5%8A%A0%E5%BC%BAvim%E5%AF%B9%E5%87%BD%E6%95%B0%E4%BD%93%EF%BC%8C%E4%BB%A5%E5%8F%8Ahtml%E7%AD%89%E6%A0%87%E7%AD%BE%E8%AF%AD%E8%A8%80%E7%9A%84%E5%A4%84%E7%90%86.html
* ci[ 删除一对 [] 中的所有字符并进入插入模式
* ci( 删除一对 () 中的所有字符并进入插入模式
* ci< 删除一对 <> 中的所有字符并进入插入模式
* ci{ 删除一对 {} 中的所有字符并进入插入模式
* cit 删除一对 HTML/XML 的标签内部的所有字符并进入插入模式
* ci” ci’ ci` 删除一对引号字符 (” 或 ‘ 或 `) 中所有字符并进入插入模

* vi[ 选择一对 [] 中的所有字符
* vi( 选择一对 () 中的所有字符
* vi< 选择一对 <> 中的所有字符
* vi{ 选择一对 {} 中的所有字符
* vit 选择一对 HTML/XML 的标签内部的所有字符
* vi” vi’ vi` 选择一对引号字符 (” 或 ‘ 或 `) 中所有字符

16.14 在插入模式下临时执行命令
ctrl+o

16.15


-----------------------------第17章结束-------------------------------

17 GNU自由文件许可证原文

        参考：http://blah.blogsome.com/2006/04/13/vim_tut_folding/

vim: foldmethod=expr: foldexpr=Fold(v\:lnum):se inde=len(split(substitute(getline(v:lnum),'^[\ \\t]*\\([0-9.]\\+\\).*','\\1',''),'\\.'))*&sw



